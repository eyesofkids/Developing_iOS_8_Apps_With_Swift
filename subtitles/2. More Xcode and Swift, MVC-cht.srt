1
00:00:00,001 --> 00:00:04,636
歡迎收看史丹佛大學公開課

2
00:00:04,638 --> 00:00:08,373
Stanford University.
本字幕由志願者義務貢獻

3
00:00:08,375 --> 00:00:11,942
>> All right, well,welcome to Stanford CS193P,
歡迎參加史丹佛大學 2015 年

4
00:00:11,944 --> 00:00:13,377
winter of 2015.
冬季學期的 CS193P 課程

5
00:00:13,379 --> 00:00:14,744
This is lecture number two.
這是我們的第二堂課

6
00:00:14,746 --> 00:00:18,581
I apologize upfront for my terrible voice, we are going
先向大家致歉我糟糕的嗓音，

7
00:00:18,583 --> 00:00:20,549
to try to get through this as best we can today.
我們今天要盡可能去試著克服這個問題

8
00:00:22,153 --> 00:00:23,819
Our topics are two fold.
我們的主題有兩個方面

9
00:00:23,821 --> 00:00:25,854
We're going to continue the calculator
我們將繼續在上一堂課已經開始的計算器展示，

10
00:00:25,856 --> 00:00:29,924
demo that we started, in last lecture and then we're gonna
之後的課程我們會有

11
00:00:29,926 --> 00:00:32,526
have some slides about this model view controller,
一些關於 model view controller，

12
00:00:32,528 --> 00:00:35,462
object-oriented design pattern that we're gonna use in
和物件導向設計模式的投影片

13
00:00:35,464 --> 00:00:36,797
everything we do.
這些都是我們將會使用在每件事上的

14
00:00:36,799 --> 00:00:40,066
When we build applications in this class.
當我們在這堂課中開發應用程式時

15
00:00:40,068 --> 00:00:41,151
All right?
有問題嗎？

16
00:00:41,152 --> 00:00:42,235
So let's get started with that demo.
那就讓我們開始進行展示

17
00:00:42,237 --> 00:00:44,136
Again, here's a slide with the summary of kind of
再重覆說明，這裡是一張總結

18
00:00:44,138 --> 00:00:46,538
the important things we're gonna talk about.
我們接下來要講的重點的投影片

19
00:00:46,540 --> 00:00:48,540
You don't need to read those in advance here,
你不需要提前閱讀這些資料

20
00:00:48,542 --> 00:00:49,708
it's more for reference.
這是參考用的

21
00:00:49,710 --> 00:00:52,410
My slides in general, I post them,
我的投影片一般是，我會貼上它們

22
00:00:52,412 --> 00:00:55,246
it's mostly intended to almost be note taking for you.
主要是為了記下和你們說了什麼

23
00:00:55,248 --> 00:00:56,580
To be able go back and try and
為了你們在復習時可以試著回想起

24
00:00:56,582 --> 00:00:58,515
figure out, whoa, when did he talked about that day?
教授他什麼時候說過有關於這些？

25
00:00:58,517 --> 00:00:59,382
Oh yeah.

26
00:00:59,384 --> 00:01:00,983
What's important, et cetera.
有那些是重要的，之類的

27
00:01:00,985 --> 00:01:03,419
So my slides do tend to be a little bit dense.
所以，我的投影片往往是有點多

28
00:01:03,421 --> 00:01:05,187
I tend to put a little more on them, than,
我會傾向於在上面多放一些內容，

29
00:01:05,189 --> 00:01:06,989
than just bullet items.
不止是列出一些大項而已

30
00:01:06,990 --> 00:01:08,790
But that's because I want you to be able to look back and
但是，那是因為我要你們能夠回頭來看時

31
00:01:08,792 --> 00:01:11,726
kind of get just a little bit more depth to
能夠更多一點深入的讓你回想起

32
00:01:11,728 --> 00:01:14,162
remind yourself what I talked about.
我所說過的這些內容

33
00:01:14,164 --> 00:01:15,363
Okay?

34
00:01:15,365 --> 00:01:17,882
All right, so
好的

35
00:01:17,883 --> 00:01:20,400
this demo, if you'll remember last time, where we left off,
這個展示，如果你還記得上次我們快結束時，

36
00:01:20,403 --> 00:01:23,603
we had gotten the keypad fully working.
我們已經讓按鈕功能可以用了

37
00:01:23,605 --> 00:01:26,606
All right, and we were talking a little bit about properties
好的，我們將要講一些關於 屬性 和

38
00:01:26,608 --> 00:01:28,808
and instant variables and how we had to initialize them.
實例變量，以及如何去初始化它們

39
00:01:28,810 --> 00:01:30,710
And so I'm gonna ask a question right at
我在上次課快要結束時，

40
00:01:30,712 --> 00:01:33,012
the end of lecture, perfect timing.
提出了那個問題，在那個很好的時間點

41
00:01:33,014 --> 00:01:37,248
What about the little outlet that we dragged out
為什麼我們拖出的

42
00:01:37,250 --> 00:01:40,284
that display UI label exclamation point, how come we
顯示 UILabel 的 outlet 後面有個驚嘆號

43
00:01:40,286 --> 00:01:43,888
didn't have to make that equal to something, to start.
以及為什麼我們從一開始不需要將它賦值

44
00:01:43,890 --> 00:01:46,123
And that's where this demo is gonna pick up.
我們將從這個地方繼續上次的 Demo

45
00:01:46,125 --> 00:01:46,890
Okay?

46
00:01:46,892 --> 00:01:49,759
Okay.

47
00:01:49,760 --> 00:01:52,627
Well, let's dive back into this demonstration,
好吧，讓我們深入到展示中來，

48
00:01:52,630 --> 00:01:54,647
where we left off.
接著我們上次講的地方

49
00:01:54,648 --> 00:01:56,665
Which it was this line of code, here.
上次我們在這行代碼結束的

50
00:01:56,668 --> 00:01:59,868
And, we had just talked about the fact that we have to
我們之前講過我們必須

51
00:01:59,870 --> 00:02:04,572
initialize all of our variables in a class,
在類中初始化我們的變量

52
00:02:04,574 --> 00:02:05,807
in any class.
在任何類中都必須這樣做

53
00:02:05,809 --> 00:02:09,510
And, so that's why we need this equals falls here.
所以我們需要在這加個等號

54
00:02:09,512 --> 00:02:13,747
They wanted the equal falls too but we needed it and yet
這裡也需要等號賦值，但是

55
00:02:13,749 --> 00:02:15,482
it didn't seem like we needed one here.
這裡看起來並不需要等號賦值

56
00:02:15,484 --> 00:02:17,050
And why was that?
為什麼會是這樣？

57
00:02:17,052 --> 00:02:19,085
Well, it turns out that this right here,
其實，這裡恰恰證明瞭

58
00:02:19,087 --> 00:02:22,254
even though it doesn't quite look like one, is an optional.
即使它看起來不完全像之前那個，這是一個 optional

59
00:02:23,490 --> 00:02:28,559
And, optionals automatically get equaled nil, given to you.
而且 optional 在你使用之前就賦了 nil

60
00:02:29,595 --> 00:02:31,862
So, you don't actually have to put the equals nil here.
所以，其實你們並不需要在這裡給它賦 nil

61
00:02:31,864 --> 00:02:35,365
So that's why, so this one here is getting initialized.
這就是為什麼這裡已經初始化了

62
00:02:35,367 --> 00:02:37,600
It's just being done automatically for you.
因為它都自動幫你做好了

63
00:02:37,602 --> 00:02:39,635
But, let's talk about the look of this thing.
但是，我們來談論一下這個東西的語法

64
00:02:40,905 --> 00:02:43,772
It's got this exclamation point here.
在這裡有個驚嘆號

65
00:02:43,774 --> 00:02:45,040
And, if it were an optional,
如果它是一個 optional 類型的值

66
00:02:45,042 --> 00:02:47,208
you'd be used to it having a question mark.
你們通常會在這裡看到一個問號

67
00:02:47,210 --> 00:02:49,310
For example, we look at this optional right here,
例如，我們來看這裡這個 optional 的值

68
00:02:49,312 --> 00:02:51,028
current title,
currentTitle,

69
00:02:51,029 --> 00:02:52,745
you see it's String question mark not exclamation point,
你們將會看到這裡 String 是問號而不是驚嘆號，

70
00:02:52,748 --> 00:02:54,665
question mark.
這裡是問號

71
00:02:54,666 --> 00:02:56,583
So what's the difference between a question mark and
那麼，這裡的問號和驚嘆號之間

72
00:02:56,585 --> 00:02:58,551
an exclamation point here?
有什麼區別呢？

73
00:02:58,553 --> 00:03:00,570
And the answer is,
答案是

74
00:03:00,571 --> 00:03:02,588
it makes no difference to the actual type, it's still
對於實際類型而言它們沒有區別，

75
00:03:02,590 --> 00:03:05,958
an optional whose value here could be a UI label.
它仍然是一個 optional 的值，其值在這裡可能是一個 UILabel 類型

76
00:03:07,161 --> 00:03:09,761
But it matters on the usage of it.
但是它們在用法上是不一樣的

77
00:03:09,763 --> 00:03:12,597
And this is purely just kind of
這完全是編譯器

78
00:03:12,599 --> 00:03:15,466
a compiler helping you out thing, here.
幫你把這事做好了

79
00:03:16,502 --> 00:03:18,602
But if we look at when I change this to
但是如果我們將這個驚嘆號改成問號

80
00:03:18,604 --> 00:03:21,538
a question mark you see that some errors appear down here.
Xcode 將會在這裡報出一些錯誤提示

81
00:03:21,540 --> 00:03:23,940
So then let's click on one of these errors, like this one,
那麼，讓我們點擊這其中的一個錯誤提示，比如說這個

82
00:03:23,942 --> 00:03:26,208
and you can see the errors that UI label,
你們會看到這個錯誤提示說 UILabel?

83
00:03:26,210 --> 00:03:29,244
question mark does not have a member named text.
沒有一個叫 text 的成員變量

84
00:03:29,246 --> 00:03:31,279
In other words you can't send text.
就是說，你不能向它發送 text 消息

85
00:03:31,281 --> 00:03:32,580
UI label question mark,
UILabel? 顧名思義

86
00:03:32,582 --> 00:03:35,350
which is what this is and that makes sense because UI label
是一個不確定值的變量，所以也就明白了 UILabel? 是

87
00:03:35,352 --> 00:03:36,784
question mark is an optional and
optional 的類型

88
00:03:36,786 --> 00:03:39,453
obviously an optional doesn't respond to text.
並且顯而易見的，一個 optional 類型的變量不會響應 text 消息

89
00:03:39,455 --> 00:03:42,889
UI labels do, but optionals don't.
UILabel 是這樣的，但 optional 並不會這樣

90
00:03:42,891 --> 00:03:44,858
So, why are we getting this error now when we
那麼回到問題，為什麼之前不會報錯

91
00:03:44,860 --> 00:03:46,726
weren't getting it before.
而現在卻出錯了呢

92
00:03:46,728 --> 00:03:47,993
And how would we get rid of this error?
我們又如何去避免這個錯誤呢？

93
00:03:47,995 --> 00:03:49,461
Well, you could certainly get rid of
嗯，我們當然可以通過

94
00:03:49,463 --> 00:03:51,630
this error by just putting an exclamation point here,
添加一個驚嘆號來避免這個錯誤

95
00:03:51,632 --> 00:03:54,399
that would unwrap this optional.
它會對這個 optional 的變量進行解包

96
00:03:54,401 --> 00:03:56,734
And now this would be an UI label right here and
那麼現在這裡剛好有一個 UILabel

97
00:03:56,736 --> 00:03:57,819
we can send a text.
如果我們要想給它發送 text 消息

98
00:03:57,820 --> 00:03:58,903
And we do the same thing up here.
就可以在這裡也做同樣的事情

99
00:03:58,905 --> 00:04:03,073
We can unwrap it there and we can unwrap it there.
我們可以在這裡對它進行解包，還有這裡也要解包

100
00:04:03,075 --> 00:04:05,742
And that gets rid of all of our errors.
這樣就解決了所有的錯誤

101
00:04:05,744 --> 00:04:09,012
But this kind of an interesting property in that
但是這裡有個很有意思的屬性 display

102
00:04:09,014 --> 00:04:11,213
even though it's not initialized in
因為它並沒有在

103
00:04:11,215 --> 00:04:14,450
the very beginning of a class creation starts out
類最開始創建時初始化成 nil

104
00:04:14,452 --> 00:04:16,451
as nil not set.
而是沒有設值

105
00:04:16,453 --> 00:04:21,723
As soon as as this user interface gets loaded up
一旦這個 UI 界面

106
00:04:21,725 --> 00:04:23,891
by this new controller.
被右邊的視圖控制器加載了

107
00:04:23,893 --> 00:04:26,794
Then this gets wired up, alright, so, that gets
那麼它就會和代碼連接起來，嗯對，只要連接起來

108
00:04:26,796 --> 00:04:30,497
wired up, and this is set, and then this it's set forever.
這個變量就會被設置並初始化，那麼它在整個類中就是永遠初始化過了

109
00:04:30,499 --> 00:04:33,199
So it's really, kinda would be sad if we actually,
但是，如果當我們每次解包時都要寫驚嘆號

110
00:04:33,201 --> 00:04:36,536
every time we used it had to unwrap it all the time.
那真是一件難過的事兒

111
00:04:36,538 --> 00:04:38,437
So these kind of properties that.
所以這些很早前就被設置過屬性變量

112
00:04:38,439 --> 00:04:42,674
Get set very early, maybe not right at creation like
不一定要和這個一樣，在創建時初始化

113
00:04:42,676 --> 00:04:44,976
this one, but very, they get set very early, and
並且，它們設置的時間非常非常的早

114
00:04:44,978 --> 00:04:46,511
then they stay set all the time.
之後一直保持著已設置的狀態

115
00:04:47,447 --> 00:04:49,030
You can, instead of
你也可以

116
00:04:49,031 --> 00:04:50,614
putting a question mark in their decoration.
在聲明的地方用一個問號來代替

117
00:04:50,616 --> 00:04:52,683
We're talking about their decoration here.
我們將在這裡談論他們的聲明

118
00:04:52,685 --> 00:04:54,317
You can put an exclamation point.
你可以在這裡加一個驚嘆號

119
00:04:54,319 --> 00:04:56,586
And what that says is.
那麼它要表達的意思是

120
00:04:56,588 --> 00:04:58,521
This is just an optional, but
這雖然只是一個 optional 類型

121
00:04:58,523 --> 00:05:03,625
always automatically unwrap it so that you don't have to
但它會自動對變量解包，從而就可以不用

122
00:05:03,627 --> 00:05:06,261
put this exclamation point in here.
在這裡加驚嘆號

123
00:05:06,263 --> 00:05:07,695
So I take this exclamation point out.
所以，我把這裡的驚嘆號刪掉了

124
00:05:07,697 --> 00:05:09,764
You can see, it's not generating any errors.
你們可以看到，它將不再報錯

125
00:05:10,933 --> 00:05:15,735
And it's still going to unwrap this display and
它將把 display 轉化成

126
00:05:15,737 --> 00:05:17,670
turn into a UI label.
UILabel

127
00:05:17,672 --> 00:05:18,838
And.
而且

128
00:05:18,840 --> 00:05:21,006
It's still gonna crash your program if for
它還是會由於

129
00:05:21,008 --> 00:05:22,307
some reason the display were nil.
某些原因比如 display 是 nil 崩潰

130
00:05:22,309 --> 00:05:25,110
If you tried to execute this code, that may
如果你執意要執行這段代碼，那是

131
00:05:25,112 --> 00:05:28,146
be impossible because this is the button sending those.
不可能的，因為這裡是由按鈕來發送這些的

132
00:05:28,148 --> 00:05:31,716
So the button wouldn't be here if this hadn't gotten already
這個按鈕不會在這裡除非它被加載

133
00:05:31,718 --> 00:05:33,818
loaded up in the set.
被賦值的時候

134
00:05:33,819 --> 00:05:35,919
But if somehow you had some place in your controller or
但是如果在某種情況下你必須

135
00:05:35,921 --> 00:05:39,589
you were accessing display before this UI got loaded.
在 UI 加載之前你要獲取 display

136
00:05:39,591 --> 00:05:42,158
It would crash, because it is unwrapping this,
它將崩潰，因為它還沒有 unwrap

137
00:05:42,160 --> 00:05:44,327
it's just that you don't have to put the explanation point,
你不需要在這裡寫驚嘆號

138
00:05:44,329 --> 00:05:46,629
it's kinda like auto explanation point.
它會自動解析

139
00:05:46,631 --> 00:05:51,066
And, this is called a implicitly unwrapped optional.
這個就叫做 unwrapped optional

140
00:05:51,068 --> 00:05:53,968
Okay? Implicitly unwrapped optional.
有問題嘛？隱式 unwrapped optional

141
00:05:53,970 --> 00:05:56,704
And it's really only useful for this kind, of property,
在這種情況下它對這類 property 來說有用

142
00:05:56,706 --> 00:06:00,274
that's, set very early, and then stay set, forever.
在創建的時候就賦值，那麼將一直被賦值

143
00:06:00,276 --> 00:06:02,642
It's kind of sugar, really.
這是一點語法的甜頭

144
00:06:04,379 --> 00:06:07,246
Okay, so let's move on
好了，我們將繼續

145
00:06:07,248 --> 00:06:11,117
to the next button in our here.
接著下一個按鈕

146
00:06:11,119 --> 00:06:13,285
Which is going to be an enter button.
它就是 Enter 鍵

147
00:06:13,287 --> 00:06:16,655
Now our calculator does not have an equals sign.
現在我們的計算器還沒有等號

148
00:06:16,657 --> 00:06:18,223
So you're probably used to calculators where you
你們也許通常會這樣使用計算器

149
00:06:18,225 --> 00:06:21,726
say six plus three then when you hit equals it shows you
6 乘以 3，然後你們按等號計算器展示

150
00:06:21,728 --> 00:06:23,027
the result.
結果

151
00:06:23,029 --> 00:06:24,912
This calculator is
我們的計算器會

152
00:06:24,913 --> 00:06:26,796
a little more like a scientific calculator.
更像科學計算器

153
00:06:26,799 --> 00:06:27,564
Has an enter key.
將沒有等號按鈕

154
00:06:27,566 --> 00:06:31,668
And so, instead you put the numbers you want to add or
那麼，你們按你們想相加的數字按鈕或者

155
00:06:31,670 --> 00:06:35,671
divide or multiply or whatever onto a stack and then when you
除以或者乘以無論什麼都將會入棧，然後當你

156
00:06:35,673 --> 00:06:38,440
press the operation keys it pulls them off the stack.
按下操作按鈕的時候，數字將會出棧

157
00:06:38,442 --> 00:06:43,011
So that looks like this, 6 enter 3 times.
比如這樣 6 3 乘

158
00:06:43,013 --> 00:06:45,279
Four, six, enter, three, enter, times.
4 6 enter 3 enter 乘

159
00:06:45,281 --> 00:06:48,449
So the times is going to pull the six and
這個乘法操作符將會把 6 和

160
00:06:48,451 --> 00:06:50,735
the three off the stack.
3 出棧

161
00:06:50,736 --> 00:06:53,020
You could even go six, enter, five, enter, four, enter, and
你也可以按 6，enter，5，enter，4， enter，然後

162
00:06:53,022 --> 00:06:54,521
then go times plus.
按乘以 加

163
00:06:55,590 --> 00:06:58,624
That would multiply the top two on the stack and
它將會把棧頂的兩個元素出棧

164
00:06:58,626 --> 00:07:00,893
then add the last one on.
操作完再將加上棧頂的元素

165
00:07:01,829 --> 00:07:04,629
So we need an enter key here for our calculator.
所以我們的計算器還是需要一個 Enter 鍵

166
00:07:04,631 --> 00:07:06,798
Now, I'm gonna create that enter key in a way that's
現在，我將要通過這種方式創建一個 enter 鍵

167
00:07:06,800 --> 00:07:09,367
actually gonna cause a problem for me in a moment, but
它雖然會引起一些問題，但是

168
00:07:09,369 --> 00:07:12,370
I wanna show you how to resolve that very problem.
我將會展示給你們看如何解決這些問題

169
00:07:12,372 --> 00:07:16,039
So I'm gonna create this enter key by copying and pasting.
那麼，我將通過複製粘貼

170
00:07:16,041 --> 00:07:18,608
This digit key right here.
這裡的數字鍵來創建 Enter 鍵

171
00:07:18,610 --> 00:07:19,475
And I'm just gonna put it in here.
那麼我將會把這放在這裡

172
00:07:19,477 --> 00:07:20,743
Notice that I'm lining these,
我通過這些藍色輔助線

173
00:07:22,113 --> 00:07:23,745
blue lines up absolutely perfectly.
把這些連接起來

174
00:07:23,747 --> 00:07:27,315
I don't want them to be, like it's lined up with that one,
我不想這按鈕放這

175
00:07:27,317 --> 00:07:28,750
but not that one or vice versa.
或者放這裡

176
00:07:28,752 --> 00:07:30,685
I want them perfectly lined up.
我希望它完全對齊

177
00:07:30,687 --> 00:07:33,520
Cuz later I'm gonna spread these out over the whole UI
因為我待會要在整個 UI 中放大這些按鈕

178
00:07:33,522 --> 00:07:37,057
and if I haven't lined these up just absolutely perfectly
如果我沒有將這些按鈕對齊的話

179
00:07:37,059 --> 00:07:39,693
then Expo's not gonna quite know what I want here in Xcode
我將不會知道它們會被

180
00:07:39,695 --> 00:07:41,828
terms of the relationship between these.
Xcode 安排到哪裡

181
00:07:43,264 --> 00:07:46,999
All right so we don't want a three on here, we want to have
好了，我們不希望這個按鈕上還是 3，所以我們需要修改一下

182
00:07:47,001 --> 00:07:52,237
a,enter symbol so I'm gonna go up here to special characters.
一個 enter 的符號，我將輸入一個特殊的符號

183
00:07:52,239 --> 00:07:54,505
This is on in most Mac applications.
這個符號在很多的 Mac 應用中都有

184
00:07:54,507 --> 00:07:57,174
You can go to the edit menu to get special characters.
你們可以從編輯菜單中獲取這些特殊符號

185
00:07:57,176 --> 00:07:58,342
And I'm going to search for
我想要搜索

186
00:07:58,344 --> 00:08:00,510
this one actually, I think that's called a return.
這個特殊符號，我覺得它應該叫 return

187
00:08:00,512 --> 00:08:01,945
Yeah. And these are just
是的，這些都是

188
00:08:01,947 --> 00:08:04,614
Unicode characters right here.
Unicode 字符

189
00:08:04,616 --> 00:08:06,615
And so I want this one that looks,
我想要這個

190
00:08:06,617 --> 00:08:09,551
kind of like a return or enter key.
看起來像返回或者 enter 按鈕的

191
00:08:10,487 --> 00:08:11,686
So I have this.
好了，我找到了

192
00:08:11,688 --> 00:08:13,721
And I'm gonna use the same mechanism we used before,
我將使用之前使用過的機制

193
00:08:13,723 --> 00:08:14,822
which is CTRL+drag.
那就是 CTRL+drag

194
00:08:14,824 --> 00:08:18,958
So I'm just gonna CTRL+drag out here.
那麼我想 CTRL+drag 拖到這裡

195
00:08:18,960 --> 00:08:21,027
And, we're creating an action,
然後，我們創建一個 action

196
00:08:21,029 --> 00:08:24,196
of course, cuz we want this button to send us a message.
當然，我們希望這個按鈕給我們發個消息

197
00:08:24,198 --> 00:08:25,431
I'm gonna call it"enter".
我將叫它 「enter」

198
00:08:26,700 --> 00:08:28,333
That's what it is the enter key
那就是我們的返回鍵.

199
00:08:28,335 --> 00:08:30,134
Now one thing is different about this one,
現在有一件事會有一點不同

200
00:08:30,136 --> 00:08:32,470
if you'll remember when we wired this action up,
如果你記得當我們連接這個 action 的時候

201
00:08:32,472 --> 00:08:35,906
we had the button that was sending it as an argument and
我們讓這個按鈕傳遞給我們一個參數

202
00:08:35,908 --> 00:08:37,441
we don't want that this time.
但是我們這次不需要這麼做

203
00:08:37,443 --> 00:08:38,808
Because there's only one answer key we
因為這裡只有一個返回鍵

204
00:08:38,810 --> 00:08:40,977
really don't need to talk back to the answer key, so
我們並不需要讓返回鍵傳參，所以

205
00:08:40,979 --> 00:08:42,712
we're going to say none right here.
我們在這裡不需要參數

206
00:08:42,714 --> 00:08:45,714
It also doesn't really matter about this type because we're
這裡我們更不用關心它的類型，因為

207
00:08:45,716 --> 00:08:46,948
not going to have an argument so
我們這裡並不需要參數

208
00:08:46,950 --> 00:08:48,750
it doesn't matter what this type is.
不用管它這裡是什麼類型

209
00:08:48,752 --> 00:08:49,717
So connect that.
所以把它們連接

210
00:08:49,719 --> 00:08:51,686
As you can see right here.
你們可以看這裡

211
00:08:51,688 --> 00:08:54,154
We have enter, and it has no arguments.
我們已經有一個 enter 鍵，沒有參數的

212
00:08:55,691 --> 00:08:57,690
Now, what are we gonna do inside enter?
那麼現在，我們將在這個 enter 里做什麼操作？

213
00:08:57,692 --> 00:08:59,558
Well, the main thing we need to do is,
好吧，我們主要要做的是

214
00:08:59,560 --> 00:09:03,228
put whatever number is in this display up here,
把 display 顯示的數字

215
00:09:03,230 --> 00:09:05,697
okay, onto our internal stack.
放入我們的棧中

216
00:09:05,699 --> 00:09:06,931
So, we're gonna need
那麼，我們需要

217
00:09:06,933 --> 00:09:09,367
an internal stack, in a moment, here.
一個棧

218
00:09:09,369 --> 00:09:10,868
Another thing we might wanna do, is.
另一件我們想做的事

219
00:09:11,904 --> 00:09:14,604
Set usersInTheMiddleOfTypeingANumber to false.
設置 usersInTheMiddleOfTypeingANumber 為 false

220
00:09:14,606 --> 00:09:17,507
Because we might have been typing a number, but
因為我們可能已經輸入了一個數字

221
00:09:17,509 --> 00:09:20,343
as soon as we hit enter, we're putting it on the stack.
但是，只要我們單擊 enter 鍵，我們將把數字放入棧中

222
00:09:20,345 --> 00:09:21,977
Next time we type a digit,
接下來我們再輸入一個數字

223
00:09:21,979 --> 00:09:23,846
we're going to be starting a new number.
我們將輸入一個新的數字

224
00:09:23,848 --> 00:09:27,182
All right, so we'll call that user in
好了，那麼我們

225
00:09:27,184 --> 00:09:29,451
the middle of typing falls there.
把它設置為 false 就好了

226
00:09:29,453 --> 00:09:32,387
Now, let's go ahead and, and actually run this and
現在，讓我們繼續，運行這個

227
00:09:32,389 --> 00:09:33,788
see how this is working.
看看它是怎麼工作的

228
00:09:33,790 --> 00:09:37,991
Because there's going to be a little problem here.
因為這裡有個小問題

229
00:09:37,993 --> 00:09:44,197
So, run this.
那麼，先運行一下

230
00:09:44,199 --> 00:09:47,499
Alright, so let's try eight, enter.
好了，讓我們試一下輸入 8，然後回車

231
00:09:47,501 --> 00:09:48,367
Oh.Oh

232
00:09:48,369 --> 00:09:50,001
What's that? Oh, my god.
那是什麼？

233
00:09:50,003 --> 00:09:52,337
Six, enter.
6，然後回車

234
00:09:52,338 --> 00:09:54,672
Well it's, it's kind of working because after we
好吧，它能運行，但是我們

235
00:09:54,674 --> 00:09:57,241
press enter the user is in the middle of typing numbers.
所按的回車也一起出現在數字裡面了

236
00:09:57,243 --> 00:09:59,160
Starts over.
重新開始

237
00:09:59,161 --> 00:10:01,078
So that's good, but I had no intention for
所以這是好的，但是我並不想

238
00:10:01,080 --> 00:10:03,380
this to be showing up on the end of my display.
讓這個在最後顯示出來

239
00:10:03,382 --> 00:10:05,115
This little enter.
這個 enter

240
00:10:05,117 --> 00:10:06,749
What the heck is that doing on there?
到底發生了什麼？

241
00:10:06,751 --> 00:10:07,783
Why is that happening?
為什麼會發生這樣的事

242
00:10:09,086 --> 00:10:09,951
Let's take a look here.
讓我們看看這裡

243
00:10:11,988 --> 00:10:15,023
The problem here, has to do with the messages being sent.
問題出在這裡，在發消息之前

244
00:10:15,025 --> 00:10:17,358
So, when we wire this up, that's good.
那麼，當我們連接好了

245
00:10:17,360 --> 00:10:20,161
We got enter.
我們已經有 enter 鍵了

246
00:10:20,162 --> 00:10:22,963
The problem is that button also sends a appendDigit.
問題是那個按鈕還傳遞 appendDigit 消息

247
00:10:22,965 --> 00:10:25,598
That's because we copied and pasted this three, remember?
那是因為我們複製粘貼的 3 的按鈕，記得麼？

248
00:10:25,600 --> 00:10:28,735
And the three sends appendDigit, until we copy and
而 3 按鈕還傳遞了 appendDigit，直到我們複製

249
00:10:28,737 --> 00:10:29,903
paste it.
粘貼了它

250
00:10:29,904 --> 00:10:31,070
Now, this one sends, sends appendDigit.
現在 ，這個按鈕發送了 appendDigit

251
00:10:31,072 --> 00:10:32,805
So this is both.
而且這個也是

252
00:10:32,807 --> 00:10:34,874
Okay, sending two.
傳遞了兩次

253
00:10:34,875 --> 00:10:36,942
Now, that's a common mistake to make.
這是一個很常見的錯誤

254
00:10:36,944 --> 00:10:39,744
You know, you only think about that when you copy and
你們知道麼，你們不會去想這些當你們複製

255
00:10:39,746 --> 00:10:41,145
paste it.
粘貼它

256
00:10:41,147 --> 00:10:42,947
And how do we fix this?
那麼我們如何來修復這個問題？

257
00:10:42,949 --> 00:10:44,348
Well if you right click, so
好了，如果你們右擊一下

258
00:10:44,350 --> 00:10:46,717
I'm going to right click on this button.
我將右鍵一下這個按鈕

259
00:10:46,719 --> 00:10:48,885
You'll get this window that comes up.
你們將會看到這個窗口

260
00:10:48,887 --> 00:10:51,687
And it shows you all the connections from this
然後你們可以看到所有的連接

261
00:10:52,723 --> 00:10:54,189
UI element to your code.
UI 元素到你們的代碼

262
00:10:54,191 --> 00:10:57,025
And you can see here both appendage and
你們可以看到這裡都連接

263
00:10:57,027 --> 00:10:58,826
enter are connected.
enter 鍵

264
00:10:58,828 --> 00:11:01,562
The great thing is I can just click this little X right here
最棒的事我可以點擊這裡的 X 按鈕

265
00:11:01,564 --> 00:11:03,530
and it'll take this connection away.
然後這個連接就被取消了

266
00:11:04,666 --> 00:11:06,232
So now I only have enter.
那麼，現在我們只有 enter 鍵的連接了

267
00:11:06,234 --> 00:11:08,101
So now if I go back here.
那麼現在我們再回到之前的地方

268
00:11:08,103 --> 00:11:09,853
See it's,
看這裡

269
00:11:09,854 --> 00:11:11,604
it's not sending appendDigit, it is sending enter.
它將不再發送 appendDigit，它只發送 enter

270
00:11:11,606 --> 00:11:14,440
And you can do this right clicking for anything.
你們可以右鍵操作任何你們想做的

271
00:11:14,442 --> 00:11:16,608
Like we need to do it for our label up here.
就像我們連接 label 一樣

272
00:11:16,610 --> 00:11:21,112
See there's the display connection we have right here.
看到沒，這裡顯示了我們的連接

273
00:11:21,114 --> 00:11:24,448
So don't forget right click to disconnect things.
不要忘記右鍵去除連接

274
00:11:24,450 --> 00:11:27,918
Now if you forget about this and you don't do it.
現在，如果你們忘記這個，你們不要去操作它

275
00:11:27,920 --> 00:11:32,455
Or maybe you have it wired to some thing that you change.
否則你們會連接一些你們修改的東西

276
00:11:32,457 --> 00:11:35,391
For example, if we have accidentally put an argument
比如，我們需要傳遞一個參數

277
00:11:35,393 --> 00:11:40,062
here to enter, if we had made it do descending button trick,
對於 enter 鍵來說，如果我們已經做過了

278
00:11:40,064 --> 00:11:42,064
kind of like this.
像這樣的

279
00:11:42,066 --> 00:11:44,432
You can't just say, oh okay.
你們不能說好的

280
00:11:44,434 --> 00:11:45,066
I'll fix that.
我將會修復它

281
00:11:45,068 --> 00:11:46,667
I'll just delete that
我將會刪除它的

282
00:11:46,669 --> 00:11:49,136
Because that would not work because,
因為它將會不工作

283
00:11:49,138 --> 00:11:52,072
enter with an argument is actually a different
因為帶有參數的 enter 鍵

284
00:11:52,074 --> 00:11:54,774
message than enter with no argument.
對於沒參數的 enter 鍵來說發送的是不同的消息

285
00:11:54,776 --> 00:11:57,510
And so, if you just deleted that when you were running
如果你們在運行的時候刪除了這些

286
00:11:57,512 --> 00:11:58,978
your program it would crash and
你的應用將會崩潰

287
00:11:58,980 --> 00:12:02,581
it would say, couldn't send message enter colon.
它會說，不能發送消息 enter:

288
00:12:02,583 --> 00:12:05,150
When you touch this button cause enter colon means enter
當你點擊 enter 鍵的時候

289
00:12:05,152 --> 00:12:08,853
with an argument, only for the purpose of this tour It doe-,
enter: 代表有參數，但是代碼中看不到

290
00:12:08,855 --> 00:12:10,655
we don't see enter colon in our code.
enter: 參數

291
00:12:10,657 --> 00:12:12,656
That's just something that's, this story board here.
這就是 Story board 中發生的一些事

292
00:12:13,793 --> 00:12:17,661
So if that happens, you need to right click on here and
那麼如果這個發生了，你需要點擊這裡

293
00:12:17,663 --> 00:12:21,431
disconnect the enter colon, that happened in there and
去除連接，然後再重新

294
00:12:21,433 --> 00:12:23,566
then you just recontrol drag.
拖拽連接

295
00:12:23,568 --> 00:12:25,834
When you recontrol drag it's nice it will.
當你重新連接好，它會變正常了

296
00:12:25,836 --> 00:12:28,103
Kind of let you try to grab onto something, so
這裡好像讓你抓住什麼東西一樣

297
00:12:28,105 --> 00:12:32,373
its easy to reconnect.
它很容易重新連接

298
00:12:32,375 --> 00:12:35,293
OKay

299
00:12:35,294 --> 00:12:38,212
All right, so now we want to actually implement enter here.
好了，那麼現在我們在這裡實現這個方法

300
00:12:38,214 --> 00:12:41,248
We want to enter the guts of it.
我們開始著手實現它的內部

301
00:12:41,250 --> 00:12:44,150
And so we are going to need another property here which is
我們需要在這定義另一個屬性

302
00:12:44,152 --> 00:12:45,702
going to be that
它將是用

303
00:12:45,703 --> 00:12:47,253
internal stack that these numbers are going to go on.
一個內部的棧去存儲這些數字

304
00:12:47,255 --> 00:12:52,057
And so that's gonna be a var just like
所以它會是一個變量，就像

305
00:12:52,059 --> 00:12:54,393
this var up here that we've created and
我們剛創建的這個變量

306
00:12:54,395 --> 00:12:57,562
I'm call it operand stack that's a good name for it.
我叫它 operandStack，不錯的名字

307
00:12:57,564 --> 00:12:58,730
And it's gonna have a type,
它會有一個類型

308
00:12:58,732 --> 00:13:02,233
it's type is going to be an array and
它的類型是數組

309
00:13:02,235 --> 00:13:05,869
just like in other languages like Java when you specify,
就像在其他語言中，比如說 Java

310
00:13:05,871 --> 00:13:08,805
when you create an array type you have to specify.
當你創建一個數組，你必須指明它的類型

311
00:13:08,807 --> 00:13:10,840
What kind of thing is in the array.
表明數組裡面存儲的是什麼

312
00:13:10,842 --> 00:13:15,211
And so, I'm gonna put doubles in my array.
因此，我打算在裡面存放 double 元素

313
00:13:17,214 --> 00:13:20,782
And that's, even though you might say, well we can't
嗯 也許你會說，好吧我們並不能

314
00:13:20,784 --> 00:13:25,286
enter doubles, because these are all integers, basically.
輸入 double，因為這裡大都是些整數

315
00:13:25,288 --> 00:13:29,723
But if I were to say, 3 enter 6 divide, I get .5.
但是假如我說，輸入 3 除以 6，我會得到 0.5

316
00:13:29,725 --> 00:13:31,925
So than a double would appear.
這樣就出現了一個 double 的結果

317
00:13:31,927 --> 00:13:34,661
So that's why I'm going to use double.
這就是我為什麼要使用 double 的原因

318
00:13:34,663 --> 00:13:38,964
Now, you can see that we've got this error up here again.
現在，你們可以看到這裡又彈出了這個錯誤

319
00:13:38,966 --> 00:13:41,133
It says stored property operandStack does not
上面說 「存儲的 property operandStack 並沒有

320
00:13:41,135 --> 00:13:43,368
have initial value.
一個初始值」

321
00:13:43,370 --> 00:13:45,036
So we have to give this an initial value.
所以我們得賦給它初始值

322
00:13:45,038 --> 00:13:47,071
So I'm going to give this an initial value of
我準備把初始值賦為

323
00:13:47,073 --> 00:13:48,472
an empty array.
一個空的數組

324
00:13:48,474 --> 00:13:51,608
So now you're seeing for the first time how you actually.
現在你們第一次看到如何

325
00:13:51,610 --> 00:13:57,480
Create an instance of a class or of a data type.
創建一個類或者數據類型的實例

326
00:13:57,482 --> 00:14:00,249
And you do that just by specifying the type and
你只需要在這指明類型

327
00:14:00,251 --> 00:14:01,984
then use parenthesis.
然後加上圓括號

328
00:14:01,986 --> 00:14:03,752
Now, we're not,
現在，我們沒有

329
00:14:03,754 --> 00:14:05,554
again we haven't talked about initializers.
我們還沒有討論過初始化方法（initializer）

330
00:14:05,556 --> 00:14:06,888
A class or
一個類或者

331
00:14:06,890 --> 00:14:09,390
a data structure can have multiple initializers.
一種數據類型可以有許多初始化方法

332
00:14:09,392 --> 00:14:11,158
Some of them might have arguments in here.
其中的一些可能會需要參數

333
00:14:12,128 --> 00:14:16,863
But most, if it's possible they'll allow you to
但大多數情況，如果允許，你都可以

334
00:14:16,865 --> 00:14:21,133
create them with no arguments and in a case on
利用沒有參數的初始化方法來創建對象

335
00:14:21,135 --> 00:14:22,835
array，it's very obvious what to do.
對於這裡的數組，很明顯

336
00:14:22,837 --> 00:14:25,103
No arguments just creates an empty array right,
不需要參數，只要創建一個空的數組

337
00:14:25,105 --> 00:14:27,739
with no elements in it.
數組內部不需要任何的元素

338
00:14:27,741 --> 00:14:31,142
Now, one thing I want to talk about is this right here.
現在，我想說一下這裡的這個東西（第一個 Array<Double>）

339
00:14:31,144 --> 00:14:32,376
This type, you know?
這個東西，你們知道嗎

340
00:14:32,378 --> 00:14:34,078
It's kind of annoying that we have to type this and
你會覺得很煩，如果在前面定義了類型

341
00:14:34,080 --> 00:14:36,147
then we have to type it right again.
然後在後面又得定義一遍

342
00:14:36,148 --> 00:14:38,215
And the answer is, we don't have to do that,
而事實上，我們並不需要這麼做

343
00:14:38,217 --> 00:14:41,051
because in swift, swift is very strongly typed.
因為 Swift 是強類型語言

344
00:14:41,053 --> 00:14:43,252
You know there's all the variables, but
所有的變量

345
00:14:43,254 --> 00:14:45,221
the properties are strongly typed.
屬性都是強類型的

346
00:14:45,223 --> 00:14:48,724
But they, there's also a lot of type inference.
而且 Swift 可以做很多的類型推斷

347
00:14:48,726 --> 00:14:50,625
So swift can infer.
類型推斷

348
00:14:50,627 --> 00:14:53,995
This type in the exact same way that digit had no type and
比如說這裡的 digit 並沒有聲明類型

349
00:14:53,997 --> 00:14:55,596
it inferred it from here.
但它可以從後面的語句中推斷出來

350
00:14:55,598 --> 00:14:58,366
OperandStack, we don't have to specify they type, and
operandStack，我們並不需要指明它的類型，因為

351
00:14:58,368 --> 00:14:59,633
it can infer it from here.
可以從這裡的初始化方法中推斷出來

352
00:14:59,635 --> 00:15:02,302
And if we option click on operandStack you'll see that
如果我們按住 option 點擊 operandStack，你會看到

353
00:15:02,304 --> 00:15:05,271
indeed, it's figured out that that's an array of double.
它確實可以辨識出這是一個 double 類型的數組

354
00:15:05,273 --> 00:15:07,824
And in fact,
事實上

355
00:15:07,825 --> 00:15:10,376
putting the type in here is considered bad form.
在這裡指明類型被認為是不好的書寫形式

356
00:15:10,378 --> 00:15:14,080
If it can be inferred, you should let it infer, so,
如果可以推斷出類型，你就應該讓它（編譯器）自己去推斷，所以

357
00:15:14,082 --> 00:15:16,915
if we didn't have this bool up here we shouldn't that either,
拿這裡的 Bool 來說，我們其實不需要聲明類型

358
00:15:16,917 --> 00:15:21,419
because, false, and true are, can only be bool values so,
因為 false 和 true 只可能是 Bool 類型的

359
00:15:21,421 --> 00:15:22,887
we're gonna take that off as well.
所以我們也可以把它去掉

360
00:15:22,889 --> 00:15:28,025
Okay, so, now, our operand
好了，那麼現在，我們這裡有操作符棧

361
00:15:28,027 --> 00:15:30,994
stack right here what do we wanna do with it?
我們打算把怎麼處理它呢？

362
00:15:30,996 --> 00:15:34,597
Well, when we press enter, we just want to append.
嗯，我們按下回車，然後我們想要 append

363
00:15:34,599 --> 00:15:35,798
So, append.
所以，append

364
00:15:35,800 --> 00:15:39,034
This is actually the first time we're sending an actual
事實上這是我們第一次發送一條

365
00:15:39,036 --> 00:15:41,703
message to an object looks just like when we
消息給一個對象，但是這種寫法就像

366
00:15:41,705 --> 00:15:43,738
accessed a property.
獲取了一個屬性一樣

367
00:15:43,740 --> 00:15:47,375
The dot and it's just the name of the method that we're
輸入點號，然後就出現了我們想要在這個數組上

368
00:15:47,377 --> 00:15:49,110
trying to invoke in our arrays.
調用的方法名字

369
00:15:49,112 --> 00:15:51,478
Just an array, an array method right here called a append.
這是一個叫做 append 的數組方法

370
00:15:51,480 --> 00:15:54,414
I think you see the arguments as newElement: T.
我想你們看到了這個參數 —— newElement: T

371
00:15:54,416 --> 00:15:57,517
This : T means it has to be of this type.
這個 : T 意味著它必須是這個類型

372
00:15:57,519 --> 00:16:00,853
Type of things in the array so this has to be a double.
這個數組裡面東西的類型，所以它必須是一個 double

373
00:16:00,855 --> 00:16:04,223
So that's kind of a problem, cuz really what I want to
這也是一個問題，因為事實上我想要在

374
00:16:04,225 --> 00:16:08,060
append onto my stack is what's up here in this display text.
我的棧上附加的是，這裡 display.text 的內容

375
00:16:08,062 --> 00:16:11,830
And, you know, I'd like to say something along the lines
然後在這行輸入

376
00:16:11,832 --> 00:16:13,164
of display.text.
display.text

377
00:16:13,166 --> 00:16:15,099
Okay? But what type is this?
好吧，它的類型是什麼呢？

378
00:16:15,101 --> 00:16:16,767
I can type display.text.（type of display.text？？）
display.text 的類型

379
00:16:18,437 --> 00:16:19,936
Now that's not String.
它不是 String

380
00:16:19,938 --> 00:16:22,205
That is an optional.
它是一個 optional String

381
00:16:22,207 --> 00:16:24,874
Remember that display.text is an optional.
記住這裡的 display.text 是一個 optional String

382
00:16:24,876 --> 00:16:28,043
So we can unwrap it even though
所以我們可以把它拆包，但

383
00:16:28,045 --> 00:16:29,911
that's not gonna solve the problem.
這並不能解決問題

384
00:16:29,913 --> 00:16:31,212
This is still a String and
這仍是一個 String

385
00:16:31,214 --> 00:16:33,381
you're still seeing an error here.
你們還是可以看到這裡有一個錯誤

386
00:16:33,383 --> 00:16:36,217
This saying 'String' is not convertible to double [COUGH].
上面寫著 「String 不可以轉化為 Double」

387
00:16:36,219 --> 00:16:37,651
Because we're supposed to be putting doubles in
因為我們本應把 Double 放入

388
00:16:37,653 --> 00:16:39,086
this array putting Strings.
這個數組而不是 String

389
00:16:39,088 --> 00:16:40,987
So, we have a problem here.
所以，我們在這有個問題

390
00:16:40,989 --> 00:16:44,323
We have somehow to convert this String into a double so
我們得用某種方式把 String 轉化成 Double 以便

391
00:16:44,325 --> 00:16:45,358
we can put it on this stack.
我們把它放入棧中

392
00:16:46,394 --> 00:16:48,994
I'm gonna use this opportunity.
我要借用這個機會，

393
00:16:48,996 --> 00:16:51,129
Just show you another feature which we
向你們展示另一個特性，我們

394
00:16:51,131 --> 00:16:52,930
call Computed Properties.
稱之為計算型屬性（Computed Properties）

395
00:16:52,932 --> 00:16:56,000
So I'm gonna create another property display value and
所以我要在這裡創建另一個屬性 displayValue,

396
00:16:56,002 --> 00:16:57,401
it's gonna be a Double.
它是一個 Double

397
00:16:57,403 --> 00:17:00,671
And what I want this to be equal to is, I always want it
然後我想讓它等於，我想讓它

398
00:17:00,673 --> 00:17:03,773
to be whatever's in this display converted to a double.
等於這裡的顯示轉化成 Double 的值

399
00:17:04,742 --> 00:17:05,786
Okay? And I want to
好了，然後我想

400
00:17:05,787 --> 00:17:06,831
be able to set it or get it so
有辦法對它進行設值以及取值，以便

401
00:17:06,832 --> 00:17:07,876
I'm gonna be able to get the value of this double.
我能夠取到這個 Double 的值

402
00:17:07,878 --> 00:17:10,112
I just want to be able to set it as a double and
我想把它設值成一個 Double 然後

403
00:17:10,114 --> 00:17:11,413
have it turn into text.
把它轉化成文本

404
00:17:13,016 --> 00:17:15,616
Well, that kind of
好吧，這種類型的

405
00:17:15,618 --> 00:17:19,886
property really is tied to some data somewhere else.
屬性實際上是與其他地方的某些數據綁定的

406
00:17:19,888 --> 00:17:22,756
So, I don't ever want to set it equal to some initial value
所以，我不想把它設成某個初始值

407
00:17:22,758 --> 00:17:25,125
or something.
還是其他的什麼

408
00:17:25,126 --> 00:17:27,493
Really, I want it to always be calculated and we can do that.
我想讓它總是由計算得到的，而我們在 Swift 里可以做到

409
00:17:27,495 --> 00:17:29,295
Instead of saying equals something,
與其輸入 「這個變量等於什麼什麼」

410
00:17:29,297 --> 00:17:32,364
you just put curly braces after.
你只需要在後面輸入，花括號

411
00:17:32,366 --> 00:17:37,168
And you say, get, and we say, set.
然後寫下 get ，再寫 set

412
00:17:37,170 --> 00:17:39,871
Okay?
就好了

413
00:17:39,872 --> 00:17:42,573
And inside here we are gonna compute the value of this.
然後在這裡面，我們要對它的值進行計算了

414
00:17:42,575 --> 00:17:46,010
Which is we are gonna convert this display text
這將會把這裡的 display.text 轉化成

415
00:17:46,012 --> 00:17:49,479
to a double and then inside here, we are, someone said,
Double，然後在這裡，我們要，要讓

416
00:17:49,481 --> 00:17:52,449
display value equal something and we are going to
displayValue 等於什麼，我們要做的是

417
00:17:52,451 --> 00:17:55,251
somehow compute, not really compute it, but.
想辦法能夠計算它，並不是真正計算某一個特定的值，而是

418
00:17:55,253 --> 00:17:58,854
We're gonna de, decide, what code we need to put that
我們要決定我們需要什麼樣的代碼能夠

419
00:17:58,856 --> 00:18:02,024
number that they tried to set the display value to in here.
決定 displayValue 在這裡被設成什麼值

420
00:18:03,126 --> 00:18:05,393
'Kay, so let's do the set side first.
好吧，那麼讓我們先來寫 set 方法

421
00:18:05,395 --> 00:18:07,695
It's actually a little simpler.
這其實會簡單一些

422
00:18:07,697 --> 00:18:08,929
Inside this set,
在 set 方法里

423
00:18:08,931 --> 00:18:11,231
there's a magic variable called new value.
會有一個叫作 newValue 的變量

424
00:18:12,300 --> 00:18:14,901
It doesn't, it's not purple for some reason, but.
因為某些原因，它的高亮並不是顯示為紫色的

425
00:18:14,903 --> 00:18:16,235
New value in this, this is the new value.
這裡的 newValue 就是將要被設置的那個值

426
00:18:16,237 --> 00:18:17,903
So if someone says somewhere in our code,
如果說某些人在我們的代碼里

427
00:18:17,905 --> 00:18:19,338
display value equals five,
讓 displayValue 的值等於 5

428
00:18:19,340 --> 00:18:21,306
this new value will have the five.
那這個 newValue 就會是 5

429
00:18:22,442 --> 00:18:23,541
And so all I really wanna do
我所想做的

430
00:18:23,543 --> 00:18:26,276
here is say display text equals the new value.
就是在這，讓 display.text 等於 newValue

431
00:18:26,278 --> 00:18:30,480
But again, of course this is an optional String.
但同樣的問題，這是個 optional String

432
00:18:30,482 --> 00:18:33,216
You can't set it to a double because displayValue equals
你不能把它設成一個 Double，因為 displayValue 等於

433
00:18:33,218 --> 00:18:36,419
five, this new values going to be a double.
5，這個 newValue 將會是一個 Double

434
00:18:36,421 --> 00:18:41,557
But we know how to convert something to a String by
但是我們知道如何把它轉化成 String，只需要寫上

435
00:18:41,559 --> 00:18:45,260
using backlash parenthesis.
反斜線，圓括號

436
00:18:45,262 --> 00:18:48,129
And this is the same thing we did when we
這其實和我們

437
00:18:48,131 --> 00:18:51,399
printed out [COUGH] our digit up here.
之前輸出的 digit 的過程是一樣的

438
00:18:51,401 --> 00:18:53,501
We just use the back slash parenthesis.
我們只需要寫上反斜線和圓括號

439
00:18:53,503 --> 00:18:55,336
It tries to convert this thing inside here,
它會試著在這裡轉化這個東西

440
00:18:55,338 --> 00:18:57,938
which is a double into a String of doubles.
把一個 Double 轉化成 String

441
00:18:57,940 --> 00:19:00,540
You know how to do that themselves.
你知道該怎麼做了

442
00:19:00,542 --> 00:19:02,575
And so bingo, we've got our display text and
沒錯 我們有了自己的 display.text

443
00:19:02,577 --> 00:19:04,477
that's all that necessary.
這就夠了

444
00:19:04,479 --> 00:19:07,479
also, every time someone sets this displayValue and then we're
而且，每次有人設 displayValue 的值時

445
00:19:07,481 --> 00:19:10,282
clearly not in the middle of typing a number anymore.
很明顯，我們知道，此時我們不在是在輸入數字的狀態了

446
00:19:10,284 --> 00:19:14,085
[INAUDIBLE] Say that.
把這個狀態設置成 false

447
00:19:14,087 --> 00:19:17,221
[INAUDIBLE] All right, what about the getting?
好吧，那關於取值呢？

448
00:19:17,223 --> 00:19:19,290
Now in the getting all we have to do is
在取值方法中，我們所要做的就是

449
00:19:19,292 --> 00:19:21,258
return this display value.
返回 displayValue

450
00:19:21,260 --> 00:19:24,161
So it's do something to calculate what this
所以這裡需要做的就是計算

451
00:19:24,163 --> 00:19:26,363
display value is here.
這裡的 displayValue

452
00:19:27,399 --> 00:19:29,215
And then return it.
然後返回它

453
00:19:29,216 --> 00:19:31,032
Now this one I'm not gonna take time to go
這次我不會花時間去

454
00:19:31,035 --> 00:19:32,801
through the details here.
詳細說明細節

455
00:19:32,803 --> 00:19:37,205
And actually I've made it an extra credit item that you can
實際上我把它算作一個給你們去做的額外加分項

456
00:19:37,207 --> 00:19:40,008
do, which requires you to figure out
需要你們利用文檔，去搞清楚我在這寫的代碼

457
00:19:40,010 --> 00:19:44,345
what I'm gonna type here using the documentation.
是什麼意思

458
00:19:44,347 --> 00:19:45,879
But I'm not going to explain it here.
但現在我不想給出代碼的解釋

459
00:19:45,881 --> 00:19:49,382
I'm gonna use a class that's in this number formatter.
這裡，我要在使用一個叫作 NumberFormatter 的類

460
00:19:49,384 --> 00:19:52,051
I'm actually gonna create one and
我先創建一個實例，然後

461
00:19:52,053 --> 00:19:56,822
I'm gonna use a method on it called number from String.
使用它的 numberFromString 方法

462
00:19:57,858 --> 00:19:59,624
And I'm gonna give it this String which is
然後我會把這個字符串傳給它，

463
00:19:59,626 --> 00:20:02,593
the display values text, unwrapped of course.
這個字符串也就是 display.text，當然得拆包

464
00:20:03,596 --> 00:20:06,497
The result is acting optional so I'm gonna unwrap that.
它的返回值是一個 optional String，所以我繼續要把它拆包

465
00:20:06,499 --> 00:20:09,499
And then I'm gonna get the double value of the thing I
然後我再得到它返回的 Double 值

466
00:20:09,501 --> 00:20:11,067
get back [COUGH].

467
00:20:11,068 --> 00:20:12,634
Number gives me this kind of generic number so
Number 給了我這種泛型的數字，所以

468
00:20:12,637 --> 00:20:14,637
I am gonna take it and turn it into a double.
我把它轉化成一個 Double

469
00:20:14,639 --> 00:20:15,738
So there we go.
好了

470
00:20:15,739 --> 00:20:16,838
So you can go the next spread and
你們可以繼續下一步了

471
00:20:16,841 --> 00:20:18,374
look at that later if you want.
如果你想的話，以後再考慮它

472
00:20:19,410 --> 00:20:20,959
But surprising to say we
高興的是，我們

473
00:20:20,960 --> 00:20:22,509
now have a property display value that when we set it and
現在有了一個 displayValue 的屬性，當我們設值和取值時

474
00:20:22,512 --> 00:20:24,579
get it, it's gonna be setting and getting.
我們調用了自定義的 set 和 get 方法

475
00:20:24,581 --> 00:20:27,415
It has a String here, so that is really convenient.
UILabel 這裡是一個字符串，所以也挺方便的

476
00:20:27,417 --> 00:20:29,400
Especially for
尤其是這裡

477
00:20:29,401 --> 00:20:31,384
right here, where we wanna say display value.
其實我們想傳入的是 displayValue

478
00:20:31,387 --> 00:20:32,285
'Kay?
明白了嗎？

479
00:20:32,287 --> 00:20:33,953
So let's see the double.
讓我們回頭檢查一下，Double

480
00:20:33,955 --> 00:20:34,987
No problem.
沒錯

481
00:20:34,989 --> 00:20:37,256
We're pinning that onto operandStack.
我們把它附到 operandStack 上了，而 operandStack 里的元素也是 Double 的

482
00:20:37,258 --> 00:20:40,058
So let's print in our operandStack here.
接下來，讓我們把 operandStack 在這打印出來

483
00:20:42,362 --> 00:20:45,162
Just so, I mean we can do the same thing here, operandStack.
就像這樣，一樣的方式，\(operandStack)

484
00:20:46,632 --> 00:20:48,649
Okay?
沒問題吧？

485
00:20:48,650 --> 00:20:50,667
And this worked because operandStack is an array, and
這種方式可行是因為 operandStack 是一個數組

486
00:20:50,669 --> 00:20:53,636
arrays know how to turn themselves into Strings.
數組知道如何把它們自身轉化成字符串

487
00:20:53,638 --> 00:20:55,938
You'll see how they do that in the console in a moment here.
你一會兒就會在控制台輸出里看到它們是怎麼做到的了

488
00:20:56,874 --> 00:20:58,040
So let's go ahead and
所以，我們繼續

489
00:20:58,042 --> 00:21:00,842
see if our application is actually putting things on
來看看我們的應用是否真的正確地能夠把東西放到

490
00:21:00,844 --> 00:21:02,343
our stack properly here.
我們的棧里

491
00:21:04,547 --> 00:21:14,054
[NOISE] All right.
好的

492
00:21:14,056 --> 00:21:14,854
Let's try here.
我們嘗試著在這裡

493
00:21:14,856 --> 00:21:18,591
Let's try 56 enter.
在這裡輸入 56

494
00:21:18,593 --> 00:21:21,761
And look, operandStack equals 56 doing good.
看，operandStack 是等於 56，運行正常

495
00:21:21,763 --> 00:21:23,128
Seven enter.
輸入 7

496
00:21:23,130 --> 00:21:24,429
All right, 56.0 and 7.0.
好的，56.0 和 7.0

497
00:21:24,431 --> 00:21:27,699
So, you can see that arrays turn themselves into Strings
所以你們看到了數組是如何把自身轉化成字符串的

498
00:21:27,701 --> 00:21:30,735
by doing open square bracket and then they turn each of
在這個方括號里，它們把自身的每個

499
00:21:30,737 --> 00:21:33,937
their elements into Strings and separated by commas.
元素轉化成字符串並以逗號分隔

500
00:21:35,507 --> 00:21:37,207
Now this is good.
這個就搞定了

501
00:21:37,209 --> 00:21:39,642
So we got our operand, operandStack building here.
我們這的 operandStack 就創建好了

502
00:21:41,179 --> 00:21:44,713
So all we need to do is have some times, and plus, and
接下來我們現在需要做的就是要有乘法，加法和

503
00:21:44,715 --> 00:21:45,947
minus buttons, etc.
減法之類的按鈕

504
00:21:45,949 --> 00:21:47,549
I'm gonna put them right here.
我準備把它們放在這個位置

505
00:21:47,551 --> 00:21:50,385
That will operate on these items uh, on the stack.
它在在這些項上進行運算，準確的說是在棧上

506
00:21:50,387 --> 00:21:52,119
So, if I pressed plus right now,
所以，如果我現在按下加

507
00:21:52,121 --> 00:21:55,122
it would pull the seven and the eight off the stack.
它就會把 7 和 8 從棧中取出來（pop）

508
00:21:55,124 --> 00:21:57,057
Add them together, it would be 15.
把他們相加，得到 15

509
00:21:57,059 --> 00:21:58,758
Show that 15 here, and
然後在這裡顯示 15

510
00:21:58,760 --> 00:22:00,560
it actually will put the 15 back on the stack.
實際上，15 會被放回到棧里（push）

511
00:22:00,562 --> 00:22:03,696
So then, we'd have 56 and 15 on our stack.
然後，我們的棧里就有了 56 和 15

512
00:22:03,698 --> 00:22:04,863
Then we could, maybe.
接著我們就可以

513
00:22:04,865 --> 00:22:08,400
Plus those together and we wanted by it plus again.
再運行一次加法，把它們加到一起

514
00:22:08,402 --> 00:22:08,933
All right?
沒錯吧？

515
00:22:08,935 --> 00:22:12,036
[COUGH] Okay.
好的

516
00:22:12,038 --> 00:22:15,539
So how are we gonna do that?
所以我們應該怎麼做呢？

517
00:22:15,541 --> 00:22:17,040
Well, we would make our buttons here.
嗯，我們將把這些運算符的按鈕放在這個位置

518
00:22:17,042 --> 00:22:22,245
And I'm gonna make the buttons again by copying and
我通過複製粘貼數字按鈕來

519
00:22:22,247 --> 00:22:24,580
pasting a digit button.
創建這些個運算符按鈕

520
00:22:24,582 --> 00:22:26,648
But this time I know about that problem,
但是這次我已經知道會出現哪個問題了

521
00:22:26,650 --> 00:22:29,584
so right off the bat I'm gonna right click on it.
所以我馬上就右鍵點擊剛才粘貼的按鈕

522
00:22:29,586 --> 00:22:31,353
And disconnect appendDigit: it.
然後取消和 appendDigit 方法的關聯

523
00:22:31,355 --> 00:22:34,472
Okay? So
好的，那麼

524
00:22:34,473 --> 00:22:37,590
now this button sends no messages, yet anyway.
現在，這個按鈕就不會發送任何消息了

525
00:22:37,593 --> 00:22:40,461
And then we could put a type on here.
然後我們要在這上面設置一個運算符

526
00:22:40,463 --> 00:22:44,331
So here I'm gonna have my all my operations buttons use
這裡我要讓所有的運算符按鈕都使用

527
00:22:44,333 --> 00:22:47,000
mathematical symbols so if we go down here to math symbols.
數學符號，而不是編程中的那些運算符號，所以我們看這裡的 Math Symbols

528
00:22:47,002 --> 00:22:49,936
See there's a bunch of math symbols here.
看這裡有好多數學符號

529
00:22:49,938 --> 00:22:51,737
So let's do times, right here,
現在，我們來給乘法設置符號

530
00:22:51,739 --> 00:22:56,775
first, we'll put times right there, and we can wire it up.
首先，把乘法放到這，然後我們可以把它與代碼鏈接在一起

531
00:22:56,777 --> 00:22:59,511
I'm just gonna hold that Ctrl and drag out here.
按住 Ctrl 然後拖動這裡來

532
00:23:00,580 --> 00:23:03,881
We're gonna call this action method.
我們把這個 Action 稱作

533
00:23:03,883 --> 00:23:05,549
Operate.
operate 方法

534
00:23:05,551 --> 00:23:09,052
And because I'm gonna have multiple operation buttons and
因為會有許多運算按鈕，所以

535
00:23:09,054 --> 00:23:11,588
they're all going to send operate.
他們都會發送 operate 消息

536
00:23:11,590 --> 00:23:13,289
Just like I did with append digit,
就像數字按鈕和 appendDigit 方法鏈接在一起一樣

537
00:23:13,291 --> 00:23:14,457
I am going to use the sender.
我要使用這個 sender

538
00:23:14,459 --> 00:23:18,193
So I'm gonna be very careful to change this any
所以我得仔細地

539
00:23:18,195 --> 00:23:19,661
object to be button.
把 Sender 的類型從 AnyObject 改成 UIButton

540
00:23:20,697 --> 00:23:22,129
Do not forget that.
不要忘記這點

541
00:23:22,131 --> 00:23:24,965
'Kay, so action, we are gonna have it sender.
Sender 類型

542
00:23:24,967 --> 00:23:25,932
UIButton.
為 UIButton

543
00:23:25,934 --> 00:23:26,666
Call it operate.
Action 名字為 operate

544
00:23:27,669 --> 00:23:28,868
There it is.
就是這些設置了

545
00:23:28,870 --> 00:23:30,269
That's method doing operate.
這就是做操作符運算的方法

546
00:23:31,338 --> 00:23:33,438
We can copy and paste this button now, right?
我們現在可以複製粘貼這個按鈕了

547
00:23:33,440 --> 00:23:34,639
We got this one, so
我們用乘法的這個

548
00:23:34,641 --> 00:23:37,775
let's copy and paste and make some more of these.
複製粘貼，然後重復，重復

549
00:23:37,777 --> 00:23:41,778
We'll start out with four of them, let's say.
我們先粘貼出 4 個運算符

550
00:23:41,780 --> 00:23:43,680
'Kay?

551
00:23:43,681 --> 00:23:45,581
Let's get back our special characters here.
我們回到特殊符號這裡

552
00:23:45,584 --> 00:23:51,087
[COUGH] All right, so let's make this one be divide.
我們來把第二個設置為除法

553
00:23:51,089 --> 00:23:53,522
Let's make this one plus.
第三個，加法

554
00:23:53,524 --> 00:23:55,924
And this one be minus.
最後一個，減法

555
00:23:55,926 --> 00:23:58,660
All right.
好了

556
00:23:58,662 --> 00:24:00,461
So we've got these buttons [COUGH].
操作符按鈕就完成了

557
00:24:00,463 --> 00:24:02,930
And they're all sending, if we look at this here,
它們都會發送，如果我們看這裡

558
00:24:02,932 --> 00:24:04,598
they're all sending operate.
它們都會發送 operate 消息

559
00:24:05,701 --> 00:24:08,535
Luckily, they're not sending anything except operate, so
幸運的是它們並不會發送運算之外的東西

560
00:24:08,537 --> 00:24:09,869
that's good.
這樣就好

561
00:24:09,871 --> 00:24:12,905
And when they send operate, we're gonna figure out
當它們發送同樣的 operate 消息的時候，我們要搞清楚

562
00:24:12,907 --> 00:24:15,808
which one is sending it by the same exact way we did above.
發送消息的對象是哪一個

563
00:24:15,810 --> 00:24:18,543
We're gonna say what is the sender's current title?
也就是說，Sender 的 currentTitle 是什麼？

564
00:24:18,545 --> 00:24:20,111
We're gonna unwrap it.
我們要把它拆包

565
00:24:20,113 --> 00:24:24,582
So operation here is gonna be a String.
這裡的 operation 是一個 String

566
00:24:24,584 --> 00:24:28,418
And it's going to tell us the title of the buttons so
它會告訴我們按鈕的 title，所以

567
00:24:28,420 --> 00:24:31,721
we know which one to use there.
我們就知道了該怎麼處理

568
00:24:31,723 --> 00:24:35,758
Now I'm gonna show you a control flow operator here in
現在我要給你們展示 Swift 中的控制流符號

569
00:24:35,760 --> 00:24:39,128
Swift that's very powerful, much more powerful than
它非常強大，比其他語言中的強大多了

570
00:24:39,130 --> 00:24:41,463
this operator is in other languages.

571
00:24:41,465 --> 00:24:43,432
And also very, very important to swift.
而且對 Swift 語言自身來說是很重要的

572
00:24:43,434 --> 00:24:46,401
I'm only gonna show you the simplest usage of it here, but
這裡我只會向你們展示控制流符號最簡單的用法

573
00:24:46,403 --> 00:24:49,170
you're gonna see on Monday's demonstration and
你們會在週一的展示和

574
00:24:49,172 --> 00:24:51,906
later in the quarter how important this operator is.
接下來的學習中感受到它的強大之處

575
00:24:51,908 --> 00:24:54,541
But, it's switch, okay, and
switch

576
00:24:54,543 --> 00:24:59,846
switch looks like switch in other languages, like C.
它和其他語言中的 switch 看起來很像，比如說 C

577
00:24:59,848 --> 00:25:01,080
You switch on something.
你在某個變量上使用 switch

578
00:25:01,082 --> 00:25:03,015
In this case I'm gonna switch on this String.
在這裡，我會在這個字符串上 switch

579
00:25:03,017 --> 00:25:04,483
This is the String.
字符串 operation

580
00:25:04,485 --> 00:25:06,852
Then you just specify the case of each thing.
然後你指明所有 case 情況

581
00:25:06,854 --> 00:25:10,822
So for example here I have a case.
舉例來說，有一個 case

582
00:25:10,824 --> 00:25:17,561
Let's do the multiply.
進行乘法

583
00:25:17,563 --> 00:25:21,031
Okay, so we've got multiply case right here.
那我們就在這裡創建一個乘法 case

584
00:25:21,033 --> 00:25:24,234
And then we just put the code that we want here
接著我們只需把做乘法的代碼

585
00:25:24,236 --> 00:25:26,203
for multiply.
放到這裡

586
00:25:26,204 --> 00:25:28,171
And we'd do that for all the other cases here.
接著對其他的操作符 case 也這麼做

587
00:25:28,173 --> 00:25:30,439
So let's copy and paste.
複製粘貼一下

588
00:25:30,441 --> 00:25:36,478
And we'll do this be our divide case.
這個是除法 case

589
00:25:36,480 --> 00:25:39,347
And we'll have this be our plus case and
這個是加法 case

590
00:25:39,349 --> 00:25:41,215
we'll have this be our,
在這裡是減法 case

591
00:25:41,217 --> 00:25:45,753
make sure we're doing the same here, plus case.
我們在複製粘貼減法 case 的時候

592
00:25:47,923 --> 00:25:49,689
Again, you've got to be a little careful here.
你需要仔細一點

593
00:25:49,691 --> 00:25:51,858
You know, this minus is slightly different from this
因為左邊的減號符號和

594
00:25:51,860 --> 00:25:54,593
minus which might be slightly different than the minus
右邊的減號符號有輕微的不同

595
00:25:54,595 --> 00:25:55,828
you type with the keyboard.
右邊的減號符號是你從鍵盤上輸入的那種

596
00:25:55,830 --> 00:25:59,164
So, when you're putting the symbols here,
所以，當你們在這放置符號的時候

597
00:25:59,166 --> 00:26:03,434
you wanna use exactly the same symbols here in your case.
你們要確保代碼中的和 Storyboard 中使用的是同一個

598
00:26:03,436 --> 00:26:06,871
Now, one thing about switch on Swift though is it
關於 Swift 中的 switch，要注意的一件事就是

599
00:26:06,873 --> 00:26:11,274
absolutely requires that you have every case covered.
你必須確保覆蓋所有情況（case）

600
00:26:11,276 --> 00:26:13,877
Now since this is a String, obviously can't have case of
由於這是一個字符串，你顯然不可能

601
00:26:13,879 --> 00:26:15,345
every single String in the universe.
窮舉每一種情況

602
00:26:15,347 --> 00:26:18,280
That is almost infinite, but luckily there,
通常是無限多的，但是很幸運的是

603
00:26:18,282 --> 00:26:22,584
you can take defaults and just break out of the switch.
可以在 default 後，使用 break 來跳出 switch

604
00:26:22,586 --> 00:26:26,187
That means if it's not one of these cases by default just
也就意味著，如果不是 default 之前列舉的那些情況

605
00:26:26,189 --> 00:26:27,088
break out of the switch.
就會跳出 switch

606
00:26:27,090 --> 00:26:28,355
You could put code here as well,
這不是說代碼不能放在 default 中

607
00:26:28,357 --> 00:26:31,091
but breaking out of it is what we wanna do in our case.
只是在這裡，我們想要從 switch 中 break 而已

608
00:26:33,028 --> 00:26:35,861
now, in here, we're just going to put the code for multiply.
現在，在這裡，我們輸入與乘法相關的語句

609
00:26:35,863 --> 00:26:37,896
So, what do we need to do for multiply?
那麼，乘法需要做些什麼?

610
00:26:37,898 --> 00:26:40,432
For the moment, I'm gonna comment this out.
我會暫時將這部分注釋掉

611
00:26:40,434 --> 00:26:42,667
I'm gonna use command, slash,
使用 ⌘ + / 鍵來注釋

612
00:26:42,669 --> 00:26:44,502
which is a really nice feature.
這個快捷鍵的確稱得上是一個很不錯的功能

613
00:26:44,504 --> 00:26:46,103
You do command slash.
按下 ⌘ + / 鍵之後

614
00:26:46,105 --> 00:26:48,238
And then command slash again, to uncomment.
再次按下 ⌘ + / 鍵來取消給代碼注釋

615
00:26:48,240 --> 00:26:55,311
[INAUDIBLE] real quick cuz I just wanna focus on times.
這裡我想專注於乘法操作的代碼

616
00:26:55,313 --> 00:26:58,247
Now any time I press any operator,
任何時候，點擊任何操作符

617
00:26:58,249 --> 00:27:02,317
I probably wanna give the user an automatic enter.
我希望自動給用戶按下 enter 按鈕

618
00:27:02,319 --> 00:27:05,087
That's so that six enter, three enter,
也就是 6，enter，3，enter

619
00:27:05,089 --> 00:27:07,989
times is the same as six enter three times.
乘法，等價於 6 乘以 3

620
00:27:09,392 --> 00:27:12,393
Okay, so six enter three times is gonna do an automatic enter
這裡，6，enter，3，乘法會自動在

621
00:27:12,395 --> 00:27:13,927
on that three.
在 3 之後輸入一個 enter

622
00:27:14,996 --> 00:27:16,596
Cuz obviously, I intend to have six and
顯然在這種情況下，我想讓 6 和

623
00:27:16,598 --> 00:27:18,998
three be multiplied in that case.
3 相乘

624
00:27:19,000 --> 00:27:26,705
So for all of these operations, I going to say,
所以，對於所有的操作符的 Action

625
00:27:26,707 --> 00:27:29,708
if the users in the middle of typing a number.
如果用戶正在輸入一個數字（userIsInTheMiddleOfTypingANumber 為 true）

626
00:27:29,710 --> 00:27:32,443
Then hit enter for me, right here.
那麼，我要自動幫用戶輸入一個 enter，即調用 enter()

627
00:27:32,445 --> 00:27:36,347
Okay, so [COUGH] what do we need to do in
接下來，我們

628
00:27:36,349 --> 00:27:39,516
this specific case of times?
需要乘法在這裡做什麼？

629
00:27:39,518 --> 00:27:42,886
Well, really we just want to set our display value.
我們需要在這裡對 displayValue 設值

630
00:27:42,888 --> 00:27:46,856
Remember we have our nice display value down here.
還記得嗎？我們自定義了 displayValue 的取值和設值方法

631
00:27:46,858 --> 00:27:49,492
And we can do setting as well as getting.
取值和設值方法

632
00:27:49,494 --> 00:27:52,094
So I set that display value.
因此，我在這裡需要做的是

633
00:27:52,096 --> 00:27:55,264
Up here.
設值

634
00:27:55,265 --> 00:27:58,433
Equal to multiplying the top two things on this stack.
displayValue 等於將棧頂的兩個數相乘

635
00:27:58,435 --> 00:28:02,270
So I can actually remove something off our stack.
因此，我可以從棧里移除一些元素

636
00:28:02,272 --> 00:28:04,705
We're representing our stack as an array.
我們可以使用一個數組代表棧結構

637
00:28:05,941 --> 00:28:07,908
Of course, they are stacked as an array.
而且，這裡確實是使用了一個數組來表示棧結構

638
00:28:07,910 --> 00:28:11,311
And so a stack is something you push things on,
棧是一種數據結構，你可以壓入元素到棧里

639
00:28:11,313 --> 00:28:12,979
you pop things off.
也可以從棧里彈出元素

640
00:28:12,981 --> 00:28:15,614
And with an array, we're just gonna add something there at
用數組實現的話，我們只需要

641
00:28:15,616 --> 00:28:17,082
the end to push something on, and
在數組的末尾添加一個元素，來模擬元素的入棧操作

642
00:28:17,084 --> 00:28:19,317
that will just remove it from the end to pop it off.
在數組的末尾移除一個元素，來模擬元素的出棧操作

643
00:28:19,319 --> 00:28:21,653
So there's a nice.
沒問題吧？

644
00:28:21,655 --> 00:28:23,654
All right. This is an array, right?
好的，這是一個數組

645
00:28:23,656 --> 00:28:26,007
Operand stacks.
數組名稱是 operandStack

646
00:28:26,008 --> 00:28:28,359
There's a nice method called remove last.
有個方法叫 removeLast()

647
00:28:28,361 --> 00:28:30,894
And if we option click on remove last, you'll see here
如果在 removeLast 方法上按住 option 鍵並單擊

648
00:28:30,896 --> 00:28:33,430
that it removes an element from the end of the array.
可以看到說明：從數組的末尾移除一個元素

649
00:28:34,666 --> 00:28:37,567
Now, it does require a count greater than zero.
這個方法需要數組的元素個數大於零

650
00:28:37,569 --> 00:28:42,705
So if our array were empty this would crash our program.
如果數組是空的話，移除元素會導致程序崩潰

651
00:28:42,707 --> 00:28:44,840
So let's put a little protective thing here.
所以，在這裡做一些保護性的措施.

652
00:28:44,842 --> 00:28:47,742
If the operand stacks.
如果 operandStack

653
00:28:47,744 --> 00:28:50,411
There's a nice property here called Count on that.
operandStack 變量有一個屬性叫做 count

654
00:28:50,413 --> 00:28:52,947
It is greater or
如果它大於或者

655
00:28:52,948 --> 00:28:55,482
equal to two actually because multiply takes two operand so
等於 2，因為乘法需要 2 個操作數

656
00:28:55,485 --> 00:28:57,484
there better two things on this stack.
所以棧中至少需要有 2 個元素

657
00:28:58,921 --> 00:29:01,121
Then we can do this and so
那麼我們可以把這取出來的棧頂元素

658
00:29:01,123 --> 00:29:05,324
we're gonna multiply that by and remove the next one.
相乘上第二次調用 removeLast() 所取出來的棧頂元素

659
00:29:05,326 --> 00:29:06,125
Okay?
明白了嗎？

660
00:29:06,127 --> 00:29:07,259
So here we got-
這樣的話

661
00:29:09,062 --> 00:29:12,463
We're just taking the last two things off of this stack by
我們從棧中移除最頂上的兩個元素

662
00:29:12,465 --> 00:29:14,832
removing them from the end of the array and
通過從數組中移除最後的元素（removeLast 方法）

663
00:29:14,834 --> 00:29:17,334
just assigning it to display value.
將運算結果賦值給 displayValue 變量

664
00:29:17,336 --> 00:29:19,469
And we probably also want to do an enter here,
接著，我們希望在這裡輸入一個 enter()

665
00:29:19,471 --> 00:29:22,539
because [COUGH] if I go six enter three times,
如果用戶按下了 6，enter，3，乘

666
00:29:22,541 --> 00:29:25,108
well then I want to be able to say then nine plus and
然後接著，用戶按下了 9，加

667
00:29:25,110 --> 00:29:28,744
have it add onto the six times three.
這代表著在原來運算的結果上加 9

668
00:29:29,713 --> 00:29:32,213
So we want an automatic enter here, as well.
所以，這裡需要一個自動點擊 enter 的操作

669
00:29:32,215 --> 00:29:34,149
Okay?
明白了嗎？

670
00:29:34,150 --> 00:29:36,084
So, that's pretty much all we need to do here.
這大概就是我們所有需要在這裡做的了

671
00:29:36,086 --> 00:29:41,021
Let's go ahead and run this, see how this works.
讓我們運行這個應用，看看它是否正常工作

672
00:29:43,826 --> 00:29:47,527
And so, six enter, or three enter, six enter.
我們嘗試輸入 3，enter，6，enter

673
00:29:47,529 --> 00:29:49,996
Now we've got them both on the stack.
我們可以從控制台看到它們已經在棧上了

674
00:29:49,998 --> 00:29:52,898
Times and you can see we put our 18 here.
然後我讓它們相乘，可以看到結果是 18

675
00:29:52,900 --> 00:29:55,668
It also put it back on the stack and
18 這個結果也被放入了棧中

676
00:29:55,670 --> 00:29:57,536
we can say five times.
我們再輸入 5，乘

677
00:29:57,538 --> 00:29:59,237
That put a five on the stack and
這個操作將 5 放入棧中,

678
00:29:59,239 --> 00:30:01,372
then multiplied them, took it off.
將它們兩個從棧中移除並相乘，返回結果

679
00:30:01,374 --> 00:30:03,107
So that's working nicely.
程序正常運行

680
00:30:03,109 --> 00:30:05,576
[COUGH] Now what about our-
現在

681
00:30:05,578 --> 00:30:06,743
Other buttons, here.
我們的其他的運算符按鈕

682
00:30:06,745 --> 00:30:08,745
We gonna make those work.
我們想要讓它們正常工作

683
00:30:08,747 --> 00:30:12,548
Let's do that.
讓我們繼續完成

684
00:30:12,550 --> 00:30:16,152
Now, they do a very similar thing, here.
其他的運算符功能和乘法的功能是十分相似的

685
00:30:16,154 --> 00:30:20,088
So, one temptation would be to just copy here.
所以，我們複製乘法的這部分代碼

686
00:30:20,090 --> 00:30:22,657
Let's uncomment these out.
先取消這部分的注釋

687
00:30:23,693 --> 00:30:25,459
And then just paste it, repeatedly.
然後重復粘貼

688
00:30:25,461 --> 00:30:26,827
So, put it there.
放到這些位置

689
00:30:27,996 --> 00:30:31,831
There, there and then just changes times in here.
只需要修改這裡的乘號

690
00:30:31,833 --> 00:30:35,868
D note to plus for example on this one.
把這個換成個加號

691
00:30:35,870 --> 00:30:39,038
But his is pretty messy code, look at all this
但是，這樣的代碼看起來很亂

692
00:30:39,040 --> 00:30:42,841
incredible amount of duplicating code, in here.
這裡有大量的重復的代碼

693
00:30:42,843 --> 00:30:47,145
We really probably wouldn't to write our code like this.
我們不希望代碼寫成這樣子

694
00:30:47,147 --> 00:30:49,780
People would think we were terrible programmers I
如果寫成這樣，別人會認為我們是很糟糕的程序員

695
00:30:49,782 --> 00:30:51,482
think if we did that.

696
00:30:51,484 --> 00:30:54,251
Really what would be nice is if we had some,
什麼樣的代碼看起來會不錯呢？

697
00:30:54,253 --> 00:30:56,453
could write some kind of function.
那就是如果我們可以把這些重復的代碼寫成函數

698
00:30:56,455 --> 00:31:00,990
Maybe we could call it perform operation or
然後給函數起名為 perfomOperation

699
00:31:00,992 --> 00:31:02,458
something like that.
或者類似意思的名字

700
00:31:02,460 --> 00:31:05,927
And if the argument to that function.
至於函數的參數

701
00:31:05,929 --> 00:31:08,196
Remember that arguments have names.
需要注意的是，函數參數也是有名字的

702
00:31:08,198 --> 00:31:09,163
Here's the name.
這就是參數的名字

703
00:31:09,165 --> 00:31:10,364
And then we have the type.
然後是參數的類型

704
00:31:11,434 --> 00:31:16,269
The argument were something which basically was this
這裡的參數是

705
00:31:16,271 --> 00:31:19,305
little operation in here, or
這裡的運算操作符

706
00:31:19,307 --> 00:31:21,707
some sort of function that would do this operation.
或者是能夠完成運算操作符操作的函數

707
00:31:21,709 --> 00:31:24,576
So if this could be some sort of function that
如果可以把這些重復代碼寫成函數的話

708
00:31:24,578 --> 00:31:25,277
would be cool.
看起來就很棒了

709
00:31:25,279 --> 00:31:27,078
Then, maybe we could.
接下來

710
00:31:27,080 --> 00:31:28,880
I take this code out of here, put it in here.
將這段代碼移動到這個位置

711
00:31:30,149 --> 00:31:34,384
Let's call it perform not pre-form, perform operation.
並起名為 performOperation

712
00:31:34,386 --> 00:31:36,353
[LAUGH] Put it in here and
放到這裡

713
00:31:36,355 --> 00:31:38,921
instead of doing, you know, multiply here.
這裡注意，我們把乘號改掉

714
00:31:38,923 --> 00:31:41,190
Let's go ahead and we can do this operation some how.
用其他的方式來進行運算

715
00:31:41,192 --> 00:31:42,891
I guess, well maybe operation,
可能是某個叫 operation 函數

716
00:31:42,893 --> 00:31:48,196
call it like a function with two arguments here.
接受兩個參數

717
00:31:51,067 --> 00:31:52,500
Okay. That would be
好了，這樣看起來很不錯了

718
00:31:52,502 --> 00:31:55,202
cool because we'd be sharing, you know, this check.
因為我們復用了這段代碼，復用了這個判讀

719
00:31:55,204 --> 00:31:57,204
We'd be sharing this enter.
復用了這 enter 方法

720
00:31:57,206 --> 00:31:59,472
[COUGH] We'd be sharing the removal of the operator.
復用了從棧中彈出兩個元素的方法

721
00:31:59,474 --> 00:32:01,441
We'd be sharing the same display value.
復用了 displayValue 變量

722
00:32:01,443 --> 00:32:04,209
We'd be kind of sharing a lot of code here and
通過這樣，復用了大段的代碼

723
00:32:05,746 --> 00:32:08,179
then up here if we could just do something like,
至於在上面的 case 中國年，我們只需要像這樣

724
00:32:08,181 --> 00:32:12,850
perform operation, and, somehow, specify,
調用函數 performOperation，並且

725
00:32:12,852 --> 00:32:16,186
multiply, as the operation we wanted to do here.
指定函數參數 multiply

726
00:32:16,188 --> 00:32:23,593
And then we wouldn't need all this stuff here, right?
原來的那一大段代碼就都不需要了，明白了嗎？

727
00:32:23,595 --> 00:32:24,527
So this is gonna be cool.
看起來很不錯

728
00:32:24,529 --> 00:32:25,995
Now, can we do this?
有人會質疑，我們可以這樣做嗎？

729
00:32:25,997 --> 00:32:28,564
Well, yes, the answer is we can.
答案是當然可以

730
00:32:28,566 --> 00:32:33,134
And so, types, functions.
參數類型，函數

731
00:32:33,136 --> 00:32:37,005
Can be types in Swift, just like any other type.
函數在 Swift 里可以被當做一種類型，就像 Swfit 中其他的類型一樣

732
00:32:37,007 --> 00:32:40,040
So, you know, we have a double here, oops, double.
你知道，這裡需要一個 Double 類型的參數

733
00:32:41,844 --> 00:32:42,809
That's a type.
就是這個類型

734
00:32:42,811 --> 00:32:43,943
You can also have a function type.
當然也可以有一個函數類型的參數

735
00:32:43,945 --> 00:32:45,611
So how do you specify a function type?
那麼，怎麼指定一個函數類型呢？

736
00:32:45,613 --> 00:32:47,846
Well multiple I or
無論是 multiple

737
00:32:47,848 --> 00:32:49,981
whatever function I'm about to perform here.
或者是任何其他我想要在這裡執行的函數

738
00:32:49,983 --> 00:32:54,686
This is a function that takes two doubles as arguments.
這樣的函數需要兩個 Double 類型的參數

739
00:32:54,688 --> 00:32:56,354
And it returns a double.
並且，它的返回值類型也是一個 Double 類型

740
00:32:56,356 --> 00:33:00,190
So, I can just say, I want operation to be
所以我在這裡輸入

741
00:33:00,192 --> 00:33:04,661
a function that takes two doubles and returns a double.
我想要 operation 是一個函數，帶兩個 Double 類型參數，返回 Double 類型

742
00:33:04,663 --> 00:33:07,363
I can express that right here.
這就是我要表達的

743
00:33:07,365 --> 00:33:11,300
This is a type, the type of this.
這就是函數類型的定義

744
00:33:12,369 --> 00:33:15,870
Argument right here that you can click on and say yeah
在函數的名稱上按住 option 單擊

745
00:33:15,872 --> 00:33:18,639
that type is double takes two doubles and returns a double.
你可以看到信息：2 個 Double 類型的參數，1 個 Double 類型的返回值

746
00:33:20,276 --> 00:33:22,176
So, just simple as that.
就是這麼簡單

747
00:33:22,177 --> 00:33:24,077
So all we need now is a function here
我們目前已知的就是，這裡有一個函數

748
00:33:24,079 --> 00:33:26,379
called multiply that takes two doubles and
這個函數名稱為 multiply，帶 2 個 Double 類型的參數

749
00:33:26,381 --> 00:33:28,514
returns a double and does multiplication.
返回 1 個 Double 類型的返回值，函數功能是完成乘法操作

750
00:33:28,516 --> 00:33:33,118
So we could go down here and say okay multiply and
接下來我們在下面輸入 multiply 函數的代碼

751
00:33:33,120 --> 00:33:35,587
you'll have op1 which is double and op2.
第一個參數 op1，Double 類型，第二個參數 op2

752
00:33:35,589 --> 00:33:39,157
[COUGH] A double and it returned the double.
Double 類型，返回一個 Double 類型

753
00:33:39,159 --> 00:33:41,926
And it's just return one times out two.
返回值是 op1 乘以 op2 的結果

754
00:33:42,962 --> 00:33:44,261
Okay?
對嗎？

755
00:33:44,263 --> 00:33:45,729
And that worked great.
一切都很好

756
00:33:45,731 --> 00:33:51,600
Back out again so we can see if this actually works.
回到上面，看它是否真的可以正常運行

757
00:33:51,602 --> 00:33:53,168
But there's no errors here.
沒有任何錯誤

758
00:33:53,170 --> 00:33:55,387
Right? It seems to work.
對麼？看起來很正常

759
00:33:55,388 --> 00:33:57,605
Multiply seems to be a function to take the $2 and
multiply 就是一個接受兩個參數，返回一個 Double 這樣的函數

760
00:33:57,608 --> 00:33:59,274
turns it double.

761
00:33:59,275 --> 00:34:00,941
And that's what this argument here is and
這就是 performOperation 的參數

762
00:34:00,944 --> 00:34:02,661
I'm passing it along.
我將 multiply 傳入

763
00:34:02,662 --> 00:34:04,379
It should all work so let's give it a try.
這一切都沒有問題，所以應該是可行的，那麼我們來試一下吧

764
00:34:08,818 --> 00:34:10,684
So here we go as six enter.
輸入 6，enter

765
00:34:10,686 --> 00:34:15,188
54 times and sure enough it's working it.
54，乘以，輸出結果是 324.0，沒問題

766
00:34:15,190 --> 00:34:17,757
It's doing that multiplication.
完成了乘法操作，我們可以在控制台輸出里看到

767
00:34:18,826 --> 00:34:23,428
Works great and so what about all of our other cases here?
乘法做的不錯，其他的 case 情況呢？

768
00:34:23,430 --> 00:34:26,731
Well we would just need to take this same.
只需要也像 multiply 這樣做

769
00:34:26,733 --> 00:34:29,400
Piece of code right here and put it for all of them.
我們在所有的 case 情況下粘貼 performOperation(multiply)

770
00:34:29,402 --> 00:34:32,169
And of course we need a divide method, so we have to
當然了，我們需要除法函數

771
00:34:32,171 --> 00:34:35,805
come down here, and copy and paste that, and make divide.
所以把這裡 multiply 改名為 divide，同時，然後複製 multiply 的實現並在它的下面粘貼更名為 divide

772
00:34:35,807 --> 00:34:37,907
Oh wait a second,
稍等

773
00:34:37,909 --> 00:34:41,210
this is starting to be just as bad as I had before.
這又像之前看起來的那樣糟糕了

774
00:34:41,212 --> 00:34:44,646
Having to make all these extra functions, multiply and
需要這些額外的函數：乘法

775
00:34:44,648 --> 00:34:46,081
divide and all that.
除法，等等

776
00:34:46,082 --> 00:34:47,515
Well [COUGH] it turns out it's so
事情上

777
00:34:47,518 --> 00:34:52,553
common to pass functions as arguments in Swift, that it
在 Swift 中，將函數作為參數傳遞是很常見的

778
00:34:52,555 --> 00:34:56,390
allows you to put a function like multiply right in
允許你在這裡傳遞一個，例如 multiply 的函數

779
00:34:56,392 --> 00:35:00,327
here without having to create a separate function like this.
而不需要單獨創建一個函數

780
00:35:00,329 --> 00:35:02,195
And all you do is you just pick it up.
所有你需要做的是就是選中函數的這塊部分

781
00:35:02,197 --> 00:35:05,131
So I'm just going to cut that from down here and
從這裡剪切

782
00:35:05,133 --> 00:35:06,599
I'm going to paste it right in here.
粘貼到上面這裡來

783
00:35:07,702 --> 00:35:10,168
The only thing you have to change syntactically when you
唯一需要在語法上做的改變的就是

784
00:35:10,170 --> 00:35:13,738
do that is this curly brace, okay.
這裡左側的花括號

785
00:35:13,740 --> 00:35:16,541
Instead of being after the declaration of
不是之前在聲明函數的參數和返回值之後

786
00:35:16,543 --> 00:35:21,779
the arguments in the return value, it needs to be before.
而是在這兩者之前

787
00:35:21,781 --> 00:35:24,314
So, you move the curly brace before.
所以，你把花括號放到前面去

788
00:35:24,316 --> 00:35:25,648
And then where the curly brace was,
之前這裡是小括號的位置

789
00:35:25,650 --> 00:35:27,417
you gonna put in, the word in.
添加一個單詞 in

790
00:35:28,586 --> 00:35:30,486
And so that allows us to just.
這裡我們稍微調整下

791
00:35:30,488 --> 00:35:34,723
Come and do that again to eliminate some of our errors.
現在把這些代碼都注釋掉，不要讓程序有錯誤

792
00:35:34,725 --> 00:35:37,291
And we can get rid of function multiply down here.
然後，我們就可以移除這裡的 func multiply 了

793
00:35:39,328 --> 00:35:42,862
So that allows me to just put that multiplier right in here.
以上這些步驟就允許我們把乘法的實現

794
00:35:42,864 --> 00:35:44,030
Right in line.
放在 case 情況的一行裡面

795
00:35:44,032 --> 00:35:46,032
Right as the argument to this function.
直接給 performOperation 函數傳遞一個函數參數

796
00:35:46,034 --> 00:35:48,167
And this things kind of wacky.
對於一些不瞭解的人來說

797
00:35:48,169 --> 00:35:49,701
For those of you who don't know it,
這種方式看起來略古怪

798
00:35:49,703 --> 00:35:51,469
user programming languages that allow this kind
但在一些編程語言中，這種寫法是允許的

799
00:35:51,471 --> 00:35:53,604
of thing to happen are called closures.
這樣的情況稱之為閉包（closure）

800
00:35:54,607 --> 00:35:56,540
It basically allows you to put a function right in there.
它允許你在這裡放置一個函數

801
00:35:56,542 --> 00:36:02,812
And this, okay here, looks okay, I mean we can certainly
好的，這樣就看起來不錯

802
00:36:02,814 --> 00:36:05,481
you know, now we can copy and paste this and put it here.
下面就可以複製，粘貼這段代碼

803
00:36:05,483 --> 00:36:06,615
You know, here and
放在除法的 case 這裡

804
00:36:06,617 --> 00:36:09,118
change this and put it here and change this.
然後將 divide 改成我們複製的代碼，以此類推，加法、減法也是如此

805
00:36:09,120 --> 00:36:12,287
But it can even be better than this.
但是，我們可以進一步改進

806
00:36:12,289 --> 00:36:15,223
So we know that Swift is really good at
我們知道 Swift 引以為傲的

807
00:36:15,225 --> 00:36:17,658
something called type inference.
一個特性稱就是類型推斷

808
00:36:17,660 --> 00:36:19,493
Where I can kinda figure out the type,
也就是我可以通過上下文（context）來

809
00:36:19,495 --> 00:36:22,863
of something, from the context.
推斷某個東西是什麼類型的

810
00:36:22,865 --> 00:36:25,165
And you can do the same thing here.
這裡你也可以這麼做

811
00:36:25,167 --> 00:36:27,267
Because its looking at performOperation.
因為 Swift 的編譯器看到這裡的 performOperation

812
00:36:27,269 --> 00:36:29,435
It knows you're calling perform operation.
它知道你在調用 performOperation

813
00:36:29,437 --> 00:36:33,039
It knows this argument is a function that takes two
它知道這個函數的參數

814
00:36:33,041 --> 00:36:34,940
doubles and returns a double.
是 2 個 Double 類型，返回值是 1 個 Double 類型的

815
00:36:34,942 --> 00:36:38,377
So you really don't have to specify all the types in here.
所以在這裡，我們不需要指定參數和返回值的類型

816
00:36:38,379 --> 00:36:39,978
Cuz it knows all of this.
因為編譯器知道這些事情

817
00:36:39,980 --> 00:36:43,381
So you can actually get rid of all these type decorations,
所以，你可以刪除這些參數類型聲明

818
00:36:43,383 --> 00:36:45,416
right here, even the return.
甚至是返回值類型也一樣可以省去

819
00:36:45,418 --> 00:36:47,851
And, again, seeing no warnings, no errors.
可以看到，刪除後，沒有任何警告和錯誤

820
00:36:47,853 --> 00:36:49,553
It knows that this has to be a double, and
它知道這個第一個參數必須是一個 Double 類型的

821
00:36:49,555 --> 00:36:51,454
this has to be a double.
第二個參數也必須是一個 Double 類型的

822
00:36:51,456 --> 00:36:53,556
Because it knows you're calling perform operation.
因為它知道你調用的是 performOperation

823
00:36:53,558 --> 00:36:56,959
So it knows the argument to that is like that.
所以，它知道函數的參數是什麼類型的

824
00:36:58,529 --> 00:37:00,962
Okay, and you can even make this look a little nicer.
好的，那麼我們可以對我們的代碼進行進一步的改進

825
00:37:00,964 --> 00:37:03,631
We can move this all up onto one line.
把這個閉包寫在一行裡面

826
00:37:04,800 --> 00:37:08,168
Really nice for readability here.
看來起更具有可讀性、更優雅

827
00:37:08,170 --> 00:37:11,037
But, we can actually do even better than this,
事實上，還能有更好的寫法

828
00:37:11,039 --> 00:37:15,074
because Swift knows that perform operations argument
因為 Swift 的編譯器知道這個函數

829
00:37:15,076 --> 00:37:18,844
returns something, you don't need this return key if your
會返回一個 Double 的值，所以你甚至都不需要使用 return

830
00:37:18,846 --> 00:37:22,715
whole is just an expression like this return key word.
如果所有的代碼只有一個返回語句

831
00:37:22,717 --> 00:37:25,717
You don't need that key word because it knows this is
那就不需要 return 這個關鍵字

832
00:37:25,719 --> 00:37:27,485
going to return something so
因為程序知道這裡，你要返回什麼東西

833
00:37:27,487 --> 00:37:32,056
this is just an expression it's going to return it.
這樣只需要輸入一個表達式就可以了，編譯器知道這個表達式的值就是你想返回的值

834
00:37:33,325 --> 00:37:37,260
But it's even better than that because a swift does
而 Swift 還有一個更棒的功能是

835
00:37:37,262 --> 00:37:40,597
not force you to name these two arguments.
Swift 不強制要求你給這兩個參數命名

836
00:37:40,599 --> 00:37:44,967
If you don‘t name them it will use the names $0.
如果不命名的參數的話，程序自動給參數起名為 $0

837
00:37:44,969 --> 00:37:46,952
$1, and
和 $1

838
00:37:46,953 --> 00:37:48,936
if you have more arguments, dollar 2, dollar 3, dollar 4.
如果你有更多的參數，將會命名為 $2，$3，$4...

839
00:37:48,939 --> 00:37:50,706
So you don't even need this.
所以，函數名字也不要了

840
00:37:52,142 --> 00:37:53,441
Okay?
明白了嗎？

841
00:37:53,443 --> 00:37:55,710
So this is a function right here.
所以這裡的意思是，這是一個函數

842
00:37:55,712 --> 00:37:58,112
It takes two doubles, dollar 0 and dollar 1, and
這個函數有兩個 Double 類型參數，名稱是 $0 和 $1

843
00:37:58,114 --> 00:37:59,546
returns a double.
返回一個 Double 類型的值

844
00:37:59,548 --> 00:38:02,916
Now Swift knows that they're doubles because it knows that
Swift 編譯器知道它們是 Double 類型

845
00:38:02,918 --> 00:38:04,517
you're passing them to perform an operation.
因為你將它們傳遞給 performOperation

846
00:38:04,519 --> 00:38:07,920
If you were passing this to some other, a function that
如果把它們傳遞給其他的函數

847
00:38:07,922 --> 00:38:10,789
took different kind of function as an argument, then,
這些函數有不一樣的參數類型，那麼

848
00:38:10,791 --> 00:38:14,126
you know, these types might be different but in this case it
$0 和 $1 的類型可能和上面不同

849
00:38:14,128 --> 00:38:16,961
knows that's what it is and it knows that it returns once
但是在這裡，Swift 知道它們是什麼類型

850
00:38:16,963 --> 00:38:20,731
it knows it's going to return what this calculation is.
也知道它們的計算結果是什麼類型的

851
00:38:21,801 --> 00:38:22,366
All right.
明白了嗎？

852
00:38:23,568 --> 00:38:26,536
Now one more cool syntactic thing you can do is if you
更酷的事情是

853
00:38:26,538 --> 00:38:29,305
have a function like performOperation, and
如果你有一個 performOperation 這樣的函數

854
00:38:29,307 --> 00:38:32,741
it has an argument which is a function like operation here,
有個像 operation 這樣的函數作為一個參數

855
00:38:32,743 --> 00:38:36,445
if this argument is the last argument, okay, so
如果這個參數是最後一個參數

856
00:38:36,447 --> 00:38:38,446
if I had other arguments before it, and
在它之前有別的參數

857
00:38:38,448 --> 00:38:42,917
this was the argument, then you can move the function.
這是傳入的參數，那麼你就可以把這個函數

858
00:38:43,886 --> 00:38:47,888
Outside the parentheses, so other arguments,
移動到括號外，至於其他的參數

859
00:38:47,890 --> 00:38:50,123
if there were other arguments before, they would go in here.
如果有的話，仍舊放在括號內

860
00:38:51,726 --> 00:38:54,327
But this last argument,
但是最後的參數除外，可以放在括號之後

861
00:38:54,328 --> 00:38:56,929
which is this operation, gets to go outside the parentheses.
也就是這個 operation，可以放在括號外

862
00:38:56,931 --> 00:38:59,564
And if there are no other arguments, if this is
如果除了最後一個參數以外，沒有其他的參數

863
00:38:59,566 --> 00:39:02,033
the only argument, you can actually get rid of that.
簡單的說，只有一個參數時，你可以把括號也去掉

864
00:39:03,870 --> 00:39:05,269
Okay.
明白了嗎？

865
00:39:05,271 --> 00:39:08,705
So, we're cutting down to incredibly concise
因此，我們把我們乘法的代碼變得相當簡潔

866
00:39:08,707 --> 00:39:13,509
language here and we can do this exact same deal,
我們再對其他的運算做同樣的事情

867
00:39:13,511 --> 00:39:18,047
of course with these other form operations.
複製粘貼這個代碼

868
00:39:18,049 --> 00:39:19,848
We just need to change the.
只需要改一下算數運算符

869
00:39:20,817 --> 00:39:21,382
Nothing here.
這裡不需要改

870
00:39:22,585 --> 00:39:24,184
This one, we be a little careful with the order of
除法需要注意的是參數的順序

871
00:39:24,186 --> 00:39:27,421
operations here, we wanna do this because we
我們想把這兩個參數的位置顛倒一下

872
00:39:27,423 --> 00:39:30,824
click the thing that we're dividing by on the stack last.
是因為我們希望，除數是棧中的最後一個元素

873
00:39:30,826 --> 00:39:34,660
And that's the first thing that comes off the stack.
而除數是棧中最先彈出的元素

874
00:39:34,662 --> 00:39:35,494
And same thing here actually,
同樣，這裡也要注意減法的參數順序

875
00:39:35,496 --> 00:39:38,163
the subtraction minus dollar here.
$1 - $0

876
00:39:38,165 --> 00:39:41,900
Okay, so, this is our entire operate, and
好了，這就是我們的全部的運算操作

877
00:39:41,902 --> 00:39:44,469
you can see that it's incredibly concise.
你可以看到，與之前相比，這相當的簡潔

878
00:39:44,471 --> 00:39:45,803
Very readable.
同時也有很高的可讀性

879
00:39:45,805 --> 00:39:47,504
Times is clearly doing this function.
一眼看上去就知道這裡是在做乘法

880
00:39:47,506 --> 00:39:48,905
And very extensible.
同時，這樣做保證了良好的可擴展性

881
00:39:48,907 --> 00:39:50,206
If you wanna add more functions,
如果你需要添加更多的操作

882
00:39:50,208 --> 00:39:51,974
we just one liners here,
只需要這裡添加一行代碼

883
00:39:51,976 --> 00:39:55,745
but more these [COUGH] binary functions that have two So,
但在這裡我們就只有這麼多二元運算

884
00:39:55,747 --> 00:39:58,814
let's go ahead and make sure these are all working.
讓我們運行一下，以確保我們應用沒有問題

885
00:40:02,753 --> 00:40:04,686
All right.
好的

886
00:40:04,687 --> 00:40:06,620
So, 6 enter 5 times, that's 30, that's good.
輸入 6，enter，5，乘法，結果是 30

887
00:40:06,623 --> 00:40:11,291
How about 47 plus 77, excellent.
再來，輸入 47，加法，結果是 77，不錯

888
00:40:11,293 --> 00:40:13,593
How about 2 divide.
再輸入 2，除法

889
00:40:13,595 --> 00:40:14,928
38.5.
結果是 38.5

890
00:40:14,930 --> 00:40:17,397
[INAUDIBLE] number there.
控制台也輸出同樣的結果

891
00:40:17,399 --> 00:40:20,299
Working, you can see the stack doing all the right things.
一切都很好，控制台的輸出也沒有問題

892
00:40:21,368 --> 00:40:24,102
Okay? Make sense?
沒問題吧？

893
00:40:24,104 --> 00:40:26,771
Now, I'm going to do one more thing, here.
現在，我還需要做一個事情

894
00:40:27,840 --> 00:40:29,473
Which is to add another operation,
就是添加另外的一個運算操作

895
00:40:29,475 --> 00:40:31,174
this is going to be a slightly different operation.
它完成一個稍有不同的操作

896
00:40:31,176 --> 00:40:32,375
So, I'm going to copy and
這裡，我複製一個運算符的按鈕

897
00:40:32,377 --> 00:40:35,144
paste these operation buttons here.
然後粘貼到這裡

898
00:40:35,146 --> 00:40:37,880
Again, I'm going to make sure they are lined up really
確保對齊

899
00:40:37,882 --> 00:40:41,350
nice with as many of these blue lines as I can get.
我使用這些藍色的線來確保對齊

900
00:40:42,786 --> 00:40:44,919
I'm actually going to leave these buttons here.
我打算把按鈕放在這個位置

901
00:40:46,255 --> 00:40:48,389
Because you're going to need them for your homework.
因為你們等下做課後作業的時候會需要用到

902
00:40:48,391 --> 00:40:50,323
But we gonna change this button right down here to be
我們將會讓這個按鈕

903
00:40:50,325 --> 00:40:51,825
a different operator.
完成成為一個不同的運算

904
00:40:52,894 --> 00:40:54,760
Which is going to be, square root.
它將是一個平方根運算符

905
00:40:54,762 --> 00:40:57,629
Which is right here, square root operator.
就在這裡，一個平方根

906
00:40:58,732 --> 00:40:59,297
All right?
有什麼問題嗎？

907
00:40:59,299 --> 00:41:05,803
And, so, I'm going to go back her to do square root, and
然後我回到這裡的代碼，添加一個平方根運算

908
00:41:05,805 --> 00:41:07,704
it's just another case, right.
只需要再添加一個 case 就可以搞定了

909
00:41:07,706 --> 00:41:08,805
Case square root.
case "√"

910
00:41:09,841 --> 00:41:12,808
And, maybe I should just be able to use the same
也許這裡我應該直接拷貝同樣的代碼

911
00:41:12,810 --> 00:41:13,709
mechanism, right?
對吧？

912
00:41:13,711 --> 00:41:14,843
Let's see if that works.
讓我們看看，這樣能不能行

913
00:41:15,946 --> 00:41:18,897
Place that in there.
把它們放在這

914
00:41:18,898 --> 00:41:21,849
And instead of this bracket here, let's use the built in
把花括號里的內容刪掉，用一個

915
00:41:21,851 --> 00:41:25,285
function in Swift to do square root called sqrt.
Swift 里內置的平方根運算函數，叫做 sqrt

916
00:41:25,287 --> 00:41:26,219
And a dollar there.
還有一個 $0

917
00:41:26,221 --> 00:41:27,187
Looks good.
看起來不錯

918
00:41:27,189 --> 00:41:29,322
And then we're ready to go.
好的，我們準備運行我們的應用

919
00:41:29,324 --> 00:41:32,591
Let's just work, call it, what's going on here.
稍等，這裡好像有什麼問題

920
00:41:32,593 --> 00:41:35,794
They have some sort of error, what's the problem.
好像是某種錯誤，是什麼問題呢？

921
00:41:35,796 --> 00:41:36,995
I don't understand.
我也不清楚

922
00:41:36,997 --> 00:41:38,163
Let's take a look at this.
我們來看一看

923
00:41:38,165 --> 00:41:42,867
Now this error is a little hard to understand but
這裡的錯誤有點難理解，不過

924
00:41:42,869 --> 00:41:46,970
basically what it's saying is that you're calling
大概意思是說，你使用的這個

925
00:41:46,972 --> 00:41:51,207
performOperation here with an argument which is a function,
performOperatin 是個函數，它接受一個函數作為一個參數

926
00:41:51,209 --> 00:41:54,177
it only takes on argument.
但是這個函數只有一個參數，正常的應該是有兩個參數

927
00:41:54,179 --> 00:41:55,378
Goes Swift looks here and
Swift 編譯器檢查了一個閉包

928
00:41:55,380 --> 00:41:57,579
it's used that it's only using a dollar zero so
發現這個函數參數只使用了一個參數 $0

929
00:41:57,581 --> 00:42:00,849
this is a one argument function this whole
也就是說這個函數只有一個參數

930
00:42:00,851 --> 00:42:03,785
curly brace thing is a function that is one argument.
大括號里只有一個參數

931
00:42:03,787 --> 00:42:07,121
Well four operation takes a function that
上面的四個運算調用的這個 performOperation 函數

932
00:42:07,123 --> 00:42:08,189
has two arguments.
有兩個參數

933
00:42:09,692 --> 00:42:11,591
So that's a mismatch that doesn't work.
所以參數個數不匹配，導致了這個錯誤

934
00:42:12,594 --> 00:42:14,694
So how can we fix this.
那麼我們來修復這個錯誤

935
00:42:14,695 --> 00:42:16,795
Well actually believe it or not we can just make a copy of
不管你相不相信，我們直接複製這個函數體

936
00:42:16,798 --> 00:42:19,398
form operation of another method, same name.
相同的函數名字

937
00:42:19,400 --> 00:42:22,067
This one we are gonna have different arguments.
但是這個函數與原來的函數有不同的參數個數

938
00:42:22,069 --> 00:42:24,736
It's gonna have a, an argument which is
將只有一個參數

939
00:42:24,738 --> 00:42:27,605
a function that only takes one double and returns a double.
只有一個 Double 參數，返回一個 Double 的值

940
00:42:28,574 --> 00:42:30,224
And then inside here,
然後在函數體的內部

941
00:42:30,225 --> 00:42:31,875
obviously we don't need topull two things off the stack,
顯然我們不需要彈出兩個元素

942
00:42:31,877 --> 00:42:32,609
just one.
只彈出一個就行了

943
00:42:32,611 --> 00:42:35,645
And obviously we only need to
同樣，我們只需要確保

944
00:42:35,647 --> 00:42:37,413
check to make sure there is one thing on the stack.
棧中至少存在一個元素

945
00:42:37,415 --> 00:42:41,950
And look, all error warnings gone, okay?
現在看一看，所有的錯誤都消失了，對吧？

946
00:42:41,952 --> 00:42:44,319
So it automatically figured out that this
所以，它自動搞清楚

947
00:42:44,321 --> 00:42:46,321
performer operation must be this one,
他必須匹配哪個 performOperation 的函數

948
00:42:46,323 --> 00:42:49,857
because this is a function that only has one argument.
因為這裡只有一個參數 $0

949
00:42:49,859 --> 00:42:52,460
And so it matched it up with this version of it.
所以它匹配了只有一個參數的函數的版本

950
00:42:52,462 --> 00:42:55,996
So in Swift, you can have functions with the same name.
所以在 Swift 中，我們讓函數有相同名字

951
00:42:55,998 --> 00:42:58,265
As long as they have different arguments.
只要他們有不同的參數就可以了

952
00:42:58,267 --> 00:42:59,399
And that Swift will
Swift 的編譯器將會

953
00:42:59,401 --> 00:43:02,168
automatically pick the right one, if it can.
自動選擇正確的一個

954
00:43:02,170 --> 00:43:03,936
There are sometimes when it's just like,
某些時候這就好比

955
00:43:03,938 --> 00:43:05,971
I can't really tell which one you mean.
你不告訴它你到底想要的是哪個

956
00:43:05,973 --> 00:43:08,673
And it will certainly complain, in that case.
在這種情況下，它當然會發牢騷了（報錯）

957
00:43:11,378 --> 00:43:14,311
But most of the type it's gonna be on [INAUDIBLE] from
但是，大部分情況

958
00:43:14,313 --> 00:43:16,647
the types involved, what's going on.
它會通過參數類型判斷到底使用哪個函數

959
00:43:16,649 --> 00:43:18,582
So, just gonna run this one again real quick.
讓我們運行一次這個程序

960
00:43:18,584 --> 00:43:22,852
[INAUDIBLE] 36 square root.
輸入 36，平方根

961
00:43:22,854 --> 00:43:27,423
Looks like it's working,9 times square root.
答案正確，再輸入 9，乘法，平方根

962
00:43:27,425 --> 00:43:27,989
Excellent.
很好

963
00:43:29,726 --> 00:43:30,291
Okay.
明白了嗎？

964
00:43:31,627 --> 00:43:33,894
All right. So,
我們繼續

965
00:43:33,895 --> 00:43:36,162
the last thing I'm going to do here is work on
我們要做的最後一件事

966
00:43:36,165 --> 00:43:37,431
the layout of these buttons.
就是設置這些按鈕的佈局

967
00:43:37,433 --> 00:43:38,531
So that's all I'm gonna do for the code.
我用代碼寫的就是這麼多

968
00:43:38,533 --> 00:43:40,333
You can see that we really didn't have to
你可以看到，我們實際上

969
00:43:40,335 --> 00:43:41,367
write that much code.
並沒有寫太多代碼

970
00:43:42,436 --> 00:43:45,003
To make this work and
來讓這個應用運行起來

971
00:43:45,005 --> 00:43:47,939
we got to do a lot of stuff in our UI here.
我們而是在 UI 上做了很多事

972
00:43:47,941 --> 00:43:50,708
So, let's go ahead and make it so these buttons spread out.
讓我們繼續，把這些按鈕位置重新擺放

973
00:43:50,710 --> 00:43:54,778
Cuz right now you see all this space is wasted right here.
因為你現在可以看到，我們浪費了很多空間

974
00:43:54,780 --> 00:43:57,481
And on an iPhone in portrait mode.
如果 iPhone 在竪屏的時候

975
00:43:57,483 --> 00:43:59,549
Whole bottom space is wasted.
我們下面的空間都浪費了

976
00:43:59,551 --> 00:44:01,484
And an iPhone on landscape mode,
如果 iPhone 在橫屏狀態

977
00:44:01,486 --> 00:44:02,685
this whole size can be wasted.
這塊區域被浪費了

978
00:44:02,687 --> 00:44:04,920
So I really want these buttons much bigger, and
所以我很想把這些按鈕弄得大一些

979
00:44:04,922 --> 00:44:05,687
stretching out.
拉伸開

980
00:44:07,124 --> 00:44:09,791
Now, when you do something like that, you have to think
現在，如果你想做類似這樣的事情，你需要認真

981
00:44:09,793 --> 00:44:12,226
a little bit of kind of what your strategy is gonna be.
思考一下到底應該怎麼做比較合適

982
00:44:12,228 --> 00:44:15,696
You can't just kinda root four start, you know,
而不是急匆匆就開始隨便就開始

983
00:44:15,698 --> 00:44:17,597
control drag it between things.
用鼠標隨便拖動這些按鈕之類的

984
00:44:17,599 --> 00:44:20,667
And trying to set up the horizontal spacing,
或是試著設置水平間距

985
00:44:20,669 --> 00:44:24,437
and maybe line up the, make the equal width and height.
或是對齊這些線，設置相同的寬度和高度

986
00:44:24,439 --> 00:44:27,106
Oh my gosh, you'd be control dragging all day long,
要是這麼做你肯定得用鼠標拖一整天

987
00:44:27,108 --> 00:44:28,374
by doing that.

988
00:44:28,376 --> 00:44:30,475
So I'm not going to use control drag to do this.
所以我不會使用鼠標拖動來做這些事

989
00:44:30,477 --> 00:44:33,945
I'm going to use these buttons down here which will kind of
我們將使用下面的這些按鈕來佈局

990
00:44:33,947 --> 00:44:36,414
bulk out a layout buttons.
這些按鈕稱之為佈局按鈕

991
00:44:36,416 --> 00:44:40,451
Let's go ahead and use the whole screen here.
我們先把這個界面擴大到全屏

992
00:44:40,453 --> 00:44:43,620
Document outline.
把左邊欄關掉

993
00:44:43,622 --> 00:44:45,939
So what is going to be my strategy?
那麼，我的策略是什麼呢?

994
00:44:45,940 --> 00:44:48,257
Well, my strategy is I'm going to make a perfect grid here.
我的策略就是在這做一個完美的網格

995
00:44:48,260 --> 00:44:52,195
So, I almost have one, except for there's one missing here.
目前已經差不多了，不過左下角還缺一個按鈕

996
00:44:52,197 --> 00:44:54,897
So I'm actually going to take a button, copy and paste it.
所以我要複製一個按鈕，然後粘貼在左下角的這個位置

997
00:44:54,899 --> 00:44:59,167
Okay, just kind of be a dummy button here actually.
把這個當做一個佔位按鈕就行了

998
00:44:59,169 --> 00:45:00,969
With no title.
不用添加任何標題

999
00:45:00,970 --> 00:45:02,770
I'm going to right click on it also because I don't want it
然後右鍵單擊這個按鈕，因為我不想讓它

1000
00:45:02,773 --> 00:45:04,939
sending appendage or anything else, So
和 controller 里的任何 Action 或者屬性關聯

1001
00:45:04,941 --> 00:45:06,841
its not going to send any messages.
現在，它就不會發送任何消息了

1002
00:45:06,843 --> 00:45:09,309
But it's just a dummy, so I'm kind of using.
現在我得費點

1003
00:45:09,311 --> 00:45:12,245
A little bit of brains over brawn here to do
腦筋來思考下這裡的佈局

1004
00:45:12,247 --> 00:45:13,680
this perfect grid.
這個完美的網格佈局

1005
00:45:13,682 --> 00:45:16,916
Now if I have this perfect grid, then if I had a rule
現在我已經有了這個網格，接下來我需要一些規則

1006
00:45:16,918 --> 00:45:20,720
where all these buttons had to be the same size, and they all
例如，這些按鈕需要相同的大小尺寸

1007
00:45:20,722 --> 00:45:24,857
had the same spacing between their neighbors, not just.
所有的按鈕都要和他相鄰的按鈕

1008
00:45:24,859 --> 00:45:28,160
Between each other but the same spacing to this edge and
有相同的間距，還要和這個邊界

1009
00:45:28,162 --> 00:45:30,929
the same spacing to this top edge.
或者頂部有相同的間距

1010
00:45:30,931 --> 00:45:33,631
Okay, if I had a rule like that then they would get
如果我有這麼一個規則，那麼

1011
00:45:33,633 --> 00:45:36,434
big and of course the spacing is facing from this edge
我們的按鈕自然就會稀疏並且

1012
00:45:36,436 --> 00:45:38,035
to edge and this edge to this edge.
與四邊有相同的間距

1013
00:45:38,037 --> 00:45:41,304
If it was all the exactly the same, which I'll make it be
如果這些按鈕都有相同的規則

1014
00:45:41,306 --> 00:45:44,708
whatever this is, whatever the dash for the lines gave me.
那麼無論這個按鈕是什麼

1015
00:45:44,710 --> 00:45:47,443
If that was the same then they would all have to spread out.
如果是規則一樣的話，他們將都延伸開來

1016
00:45:48,479 --> 00:45:50,179
Okay, they'd get bigger but
好的，按鈕之間會變的更稀疏，但是

1017
00:45:50,180 --> 00:45:51,880
they'd all stay the same size because I'm going to
我希望他們的尺寸都保持現在的大小，因為

1018
00:45:51,882 --> 00:45:54,516
make a rule that they have to be the same size.
我將制定一個規則來使他們保持大小

1019
00:45:54,518 --> 00:45:56,317
But they would move out to this edge so
但是這些按鈕將移到這邊

1020
00:45:56,319 --> 00:46:00,121
that this nearest neighbor would be the same, you know,
並且最近的元素保持相同的距離

1021
00:46:00,123 --> 00:46:02,322
this distance would be the same as this distance.
例如這個按鈕到右邊的間距將和它到它左側按鈕的間距是一樣

1022
00:46:02,324 --> 00:46:05,092
So that's my strategy, I'm going to try to do that.
這就是我的想法，我們嘗試一下

1023
00:46:05,094 --> 00:46:06,760
Now to make that work,
現在就開始

1024
00:46:06,762 --> 00:46:09,128
all these buttons need to know who their nearest neighbor is.
所有這些按鈕需要知道他們的最近的元素是誰

1025
00:46:09,130 --> 00:46:11,564
Well, these all know their nearest neighbor here,
好，這些都知道他們的最近的元素

1026
00:46:11,566 --> 00:46:13,999
the other buttons, because I made sure I used dashed
也就是其他按鈕的，因為當我拖拽它們時

1027
00:46:14,001 --> 00:46:17,035
blue lines when I dragged them in there.
我確保使用的藍色虛線來對齊它們

1028
00:46:17,037 --> 00:46:18,303
So, that's what kind of
這也是某種

1029
00:46:18,305 --> 00:46:19,904
teaches them their nearest neighbor.
確定它們最近的元素的一種方式

1030
00:46:19,906 --> 00:46:22,573
And I'm also going to make sure that the entire grid
接下來，我要確保整個網格

1031
00:46:22,575 --> 00:46:25,442
knows that the left edge and
知道它的左邊界

1032
00:46:25,444 --> 00:46:29,046
just under the label there, our nearest neighbor.
並且，知道它就位於這個標籤的下面

1033
00:46:29,048 --> 00:46:30,447
So now it knows on the top,
現在，它知道

1034
00:46:30,449 --> 00:46:32,348
the nearest neighbor is the label, and
離它最近的頂部元素是這個標籤，並且

1035
00:46:32,350 --> 00:46:34,383
on the left is this edge.
離它最近的左邊元素是這個邊界

1036
00:46:34,385 --> 00:46:37,386
And it's going to pick this edge as
我們要做的就是讓這些按鈕知道，右側的邊界是離他們最近的右側元素

1037
00:46:37,388 --> 00:46:39,888
the nearest neighbor for these buttons and the bottom edge,
底部的邊界是離他們最近的底部元素

1038
00:46:39,890 --> 00:46:41,356
cuz that's all there is and
因為這兒沒有其他的東西

1039
00:46:41,357 --> 00:46:42,823
nothing else out here that's gonna become,
可以成為這些按鈕的最近的元素

1040
00:46:42,826 --> 00:46:45,326
that's the only neighbor there is, it's gonna pick those.
它們只能選擇這兩個邊界

1041
00:46:47,263 --> 00:46:48,962
So now that I've used my dash for
那麼，現在我已經使用這些虛線

1042
00:46:48,964 --> 00:46:51,898
the lines it makes this all quite easy.
這將變的很容易

1043
00:46:51,900 --> 00:46:53,866
Now, if you don't use the dash for the lines, or
如果你不使用這些虛線

1044
00:46:53,868 --> 00:46:56,602
if you make some mistakes then it's not going to work.
或者你搞錯了什麼的話，它就不會有效的

1045
00:46:56,604 --> 00:47:00,305
This strategy won't work and I've made doing this part of
我做的這部分展示

1046
00:47:00,307 --> 00:47:03,809
this demonstration be extra credit.
是額外的

1047
00:47:03,811 --> 00:47:06,044
And so if you can't get it, don't worry about it too much,
因此，如果你不能做到或者不明白的話，也不必太擔心

1048
00:47:06,046 --> 00:47:09,247
just keep all your buttons in the upper left corner here
只需保持你所有的按鈕在左上角

1049
00:47:09,249 --> 00:47:11,199
and that's fine.
這就好了

1050
00:47:11,200 --> 00:47:13,150
But if you want to give this a try, the key is to
但是如果你想嘗試一下我所做的

1051
00:47:13,152 --> 00:47:15,753
use the dash lines to make the perfect grid.
重點是使用虛線，來確保整個按鈕網格是對齊的

1052
00:47:15,755 --> 00:47:18,822
Make sure that you set the nearest neighbors here by
同時通過拖拽整個網格確保你將左側邊界和這個標籤

1053
00:47:18,824 --> 00:47:23,793
dragging the whole grid to make blue lines appear on the sides.
設置為離這些按鈕最近的上部元素和左側元素

1055
00:47:23,795 --> 00:47:26,962
And then, we are going to set these rules in bulk and
然後，我們來設置這些規則

1056
00:47:26,964 --> 00:47:29,965
we do that with these buttons down here.
我們可以用下面的這些按鈕

1057
00:47:29,966 --> 00:47:32,967
So there's this button right here the left most button and
在最左邊的這個按鈕

1058
00:47:32,969 --> 00:47:36,337
it let's you set things like lining up leading edges or
它可以設置左邊對齊

1059
00:47:36,339 --> 00:47:37,872
the tops or the centers.
上邊對齊或者居中

1060
00:47:37,874 --> 00:47:40,174
And you could imagine there might be a way to do this by
也許你能想到，利用這些，可以實現我們想要的佈局

1061
00:47:40,176 --> 00:47:42,542
doing that but I am not going to use that strategy.
但是我們在這裡不會這麼做

1062
00:47:42,544 --> 00:47:45,045
My strategy is just make them the same size and
我的方法就是讓它們的大小一樣

1063
00:47:45,047 --> 00:47:48,447
make the space in between them, be the same.
並且它們之間的間距也一樣

1064
00:47:49,617 --> 00:47:51,450
But, I bet there's probably a way to do it by
但是，我相信，也許通過中點的方式

1065
00:47:51,452 --> 00:47:54,919
lining up their centers, or something like that, too.
或者類似的方式也可以做到一樣的效果

1066
00:47:54,921 --> 00:47:56,921
So I'm not going to use this one.
因此，我這裡不打算使用個按鈕

1067
00:47:56,923 --> 00:47:59,357
The next one over,
下一個按鈕

1068
00:47:59,358 --> 00:48:01,792
right here, is the one that has the things I want.
這裡就有我想要的東西

1069
00:48:01,794 --> 00:48:04,094
And so you can see that it'll ask you to
正如你所看見的，它會讓你選擇

1070
00:48:04,096 --> 00:48:06,196
make all the buttons equal widths and heights.
是否讓所有按鈕的寬度相等、高度相等

1071
00:48:06,198 --> 00:48:07,464
Okay, not width and
沒有勾選的這兩個選項（Width，Height）

1072
00:48:07,466 --> 00:48:09,832
height, that fixes them at a certain width and
是用來將它們修改成某個特定的寬度和高度的

1073
00:48:09,834 --> 00:48:12,401
height, this means that there,they can be any width and
但是這裡的意思是，對於所有的這些按鈕，寬度和高度可以是任意的值

1074
00:48:12,403 --> 00:48:14,803
height they want, but they all have to be the same width and
但是他們必須擁有相同的寬度和相同的高度

1075
00:48:14,805 --> 00:48:16,938
height all these buttons.

1076
00:48:16,940 --> 00:48:18,840
Of course I had these all selected by the way, if you
當然，我把這些按鈕都選中了

1077
00:48:18,842 --> 00:48:20,842
don't have them selected it doesn't make any sense.
如果你沒選中那就不會應用這些規則

1078
00:48:22,011 --> 00:48:23,711
And then up here, you can see there is spacing to
然後在這裡，你可以看到這是一個 Spacing to

1079
00:48:23,713 --> 00:48:25,679
nearest neighbor, so this is where I am going to set
nearest neighbor 的面板，我們把這些

1080
00:48:25,681 --> 00:48:29,716
that spacing between all these, to be the same.
按鈕之間的間距設為一樣

1081
00:48:29,718 --> 00:48:31,417
And you can see that it's put eight here.
正如你所看到的，這裡設置為 8

1082
00:48:31,419 --> 00:48:33,585
That's because when I did the dash lines
這是因為當我使用虛線對齊元素時

1083
00:48:35,022 --> 00:48:39,323
to the top eight seems to be kind of a standard number of
標準的間距就是 8 個像素點

1084
00:48:39,325 --> 00:48:42,727
points between elements.

1085
00:48:42,729 --> 00:48:45,429
These are all multiple because some of these buttons,
這裡顯示所有的左間距為 Multiple，那是因為這些按鈕中

1086
00:48:45,431 --> 00:48:48,432
their nearest neighbor is way over here and it's huge.
有些最近的元素是右邊界，這是一個巨大的數值

1087
00:48:48,434 --> 00:48:50,250
All right.
明白了嗎？

1088
00:48:50,251 --> 00:48:52,067
The bottom or their right.
最近的下邊元素和右邊元素的數值不一樣導致 Multiple

1089
00:48:52,070 --> 00:48:55,838
But all these buttons,the thing on top,
所有這些按鈕，最近的上部元素

1090
00:48:55,840 --> 00:48:58,274
whether it's another button or whether it's this label,
無論是另一個按鈕或者是這個標籤

1091
00:48:58,276 --> 00:49:01,343
all of them happen to be this eight points right here.
他們的間距都是 8 個像素點

1092
00:49:01,345 --> 00:49:03,178
So I want all of these to be eight.
我想讓這些都設置為 8 個像素點

1093
00:49:03,180 --> 00:49:07,482
So I'm just going to turn this bar on right here, which says,
在這裡我們打開這一欄

1094
00:49:07,484 --> 00:49:11,018
yes please enforce, and make the rule that all of
「 請確保這些所有

1095
00:49:11,020 --> 00:49:15,255
these are 8 points from their nearest neighbor to the top.
按鈕的到距離它頂部最近元素距離為 8 個像素點 」

1096
00:49:15,257 --> 00:49:18,124
And also, 8 to the left,8 to the right, and
同樣，左邊間距為 8 個像素點，右邊間距為 8 個像素點

1097
00:49:18,126 --> 00:49:19,459
8 to the bottom.
底部間距也為 8 個像素點

1098
00:49:19,461 --> 00:49:21,060
Really wanna make sure these beams are on,
確保這裡是打開的

1099
00:49:21,062 --> 00:49:23,362
if these beams are off,even if there's a number here,
如果他是關閉的，即使這裡有數字

1100
00:49:23,364 --> 00:49:24,963
then it's not gonna add this rule.
也不會添加規則的

1101
00:49:24,965 --> 00:49:26,998
So we wanted to add this rule.·
我們想要添加這些規則

1102
00:49:27,000 --> 00:49:30,101
So this adds up to
87 different rules.
所以總共有 87 個不同的規則

1103
00:49:30,103 --> 00:49:32,554
All these equal widths and
所有相同寬度，相同高度

1104
00:49:32,555 --> 00:49:35,006
heights and all these So if you don't have 87 in here,
以及這些，如果你的規則的數目不是 87

1105
00:49:35,008 --> 00:49:36,974
if it says a hundred and something,
假如是 100 或者其它，

1106
00:49:36,976 --> 00:49:39,209
probably you don't have everything lined up right.
那麼很可能你沒有將所有東西正確對齊起來

1107
00:49:39,211 --> 00:49:43,279
It only takes 87 constraints to express all these rules.
只需要 87 個規則就可以表示我們想要的網格佈局

1108
00:49:44,482 --> 00:49:45,547
All right.
明白了嗎？

1109
00:49:45,549 --> 00:49:48,316
Now, when I click this Add 87 Constraints it's
現在，如果我按下 「Add 87 Constraints」

1110
00:49:48,318 --> 00:49:51,886
going to add these rules to all these buttons, and
就會在這些按鈕上添加這些規則

1111
00:49:51,888 --> 00:49:52,787
watch what happens.
看看會發生什麼

1112
00:49:54,790 --> 00:49:56,723
So, I get all kinds of,
嗯，我得到了很多的線

1113
00:49:56,725 --> 00:49:59,392
first these blue lines are showing me the rules.
首先這些藍色的線表示規則

1114
00:49:59,394 --> 00:50:01,094
'Kay? A lot them are saying here
許多藍色的線代表這裡

1115
00:50:01,096 --> 00:50:03,062
that things are equal widths and heights.
的按鈕都是相同長度和寬度的

1116
00:50:03,064 --> 00:50:05,531
So these are what equals rules means.
這就是 equals 規則的意思

1117
00:50:05,533 --> 00:50:08,700
But there's also tiny little I beams right up here.
這裡還有一些小的 I 形狀的線

1118
00:50:08,702 --> 00:50:13,671
That are showing this basing to nearest neighbor, and
I 行的線表示以最近的物體為基準

1119
00:50:13,673 --> 00:50:16,073
also like there's a yellow, yellow here.
這裡還有一些黃色的線

1120
00:50:16,075 --> 00:50:18,409
This yellow, remember, means yeah,
記住，這些黃色的線代表

1121
00:50:18,411 --> 00:50:21,044
there's constraints on these, but they're not actually where
這裡雖然有一些規則，但是這些東西的位置本不應該

1122
00:50:21,046 --> 00:50:23,113
they're supposed to be based on those rules.
放置在這裡，也就是說，目前的位置和預想的位置有偏差

1123
00:50:24,049 --> 00:50:27,016
So we really want to move them all to be in their
我們很需要將這些按鈕，按照這些規則

1124
00:50:27,018 --> 00:50:29,852
proper spaces based on these rules.
移動到合適的地方

1125
00:50:29,854 --> 00:50:31,753
That's what these dashed yellow lines mean.
這就是這些黃色的線的意思

1126
00:50:31,755 --> 00:50:33,221
So we can do the same thing to do that,
我們可以像按剛開始

1127
00:50:33,223 --> 00:50:36,224
that we did at the beginning with the label on the top
處理頂部的標籤那樣

1128
00:50:36,226 --> 00:50:38,225
which is go to our document outline here,
點擊左下角的 document outline 菜單

1129
00:50:38,227 --> 00:50:39,393
in the lower left corner.

1130
00:50:39,395 --> 00:50:42,929
Okay these are document outline when we last saw it,
這些是 UI 文檔的縮略圖，上一次我們查看時

1131
00:50:42,931 --> 00:50:45,331
it only had this one label in there.
只有這一個標籤在這裡

1132
00:50:46,401 --> 00:50:47,700
Now we got all these buttons added.
現在把所有的按鈕都添加上來了

1133
00:50:47,702 --> 00:50:50,002
And you can see they're all selected.
而且你看到這些按鈕都處於選中狀態

1134
00:50:50,004 --> 00:50:52,304
All selected here as well.
在 Storyboard 中也處於全部選中的狀態

1135
00:50:52,306 --> 00:50:54,673
And, we've got this little yellow thing up here.
這上面有一個黃色的小箭頭

1136
00:50:54,675 --> 00:50:58,643
Now, if this is red, okay, if you do all this and
如果這裡是紅色箭頭，如果你做了之前的這些操作

1137
00:50:58,645 --> 00:51:02,747
this is red, well that means that you've got not just
並且是紅色箭頭，那就意味著你所添加的

1138
00:51:02,749 --> 00:51:05,516
warnings that your constraints aren't in the right place, but
規則不僅是警告，警告你目標的位置和預期的規則不同

1139
00:51:05,518 --> 00:51:08,452
you've got errors, usually conflicting constraints,
而且有錯誤，錯誤通常是由規則之間的衝突所引起

1140
00:51:08,454 --> 00:51:11,721
where you've asked auto layout to
當你讓自動佈局強制

1141
00:51:11,723 --> 00:51:13,890
enforce two rules that conflict with each other.
實施兩種相互衝突的規則時

1142
00:51:13,892 --> 00:51:17,626
So if you get to that red, this is not going to work.
所以如果箭頭是紅色，這些規則就不會正常工作

1143
00:51:17,628 --> 00:51:20,295
So, you'll want to start over, and
這是，你可能想重新再設置一遍

1144
00:51:20,297 --> 00:51:23,432
I'll show you in a minute how you can start over if things,
我稍後為大家展示怎麼再重新開始

1145
00:51:23,434 --> 00:51:26,234
or not going your way, but if it's yellow that just means
如果和你想的不同，黃色箭頭

1146
00:51:26,236 --> 00:51:27,201
things were in the wrong place.
僅代表有些東西在錯誤的位置

1147
00:51:27,203 --> 00:51:29,136
So no problem, we click the yellow.
很簡單，點擊黃色箭頭

1148
00:51:29,138 --> 00:51:30,637
Here's all the things that were in the wrong place.
這裡是在錯誤位置的東西

1149
00:51:30,639 --> 00:51:31,972
This is all the buttons,
這是所有的按鈕

1150
00:51:31,974 --> 00:51:34,274
you can see they highlight as I mouse over them.
你可以看到當鼠標移到按鈕上時，對應的按鈕高亮

1151
00:51:34,276 --> 00:51:38,077
And you can really pick on any one of them to fix this
你可以任意選一個來修改

1152
00:51:38,079 --> 00:51:40,880
because there's a nice little switch here called apply to
因為這裡有一個很方便的復選框，它代表

1153
00:51:40,882 --> 00:51:42,047
all views and containers.
將修改應用到所有視圖（views）和容器（containers）

1154
00:51:42,049 --> 00:51:44,116
You don't have to click on each one and
你就不必每一個都點擊

1155
00:51:44,118 --> 00:51:46,985
have it to frame update to the proper thing.
使它的 frame 更新到合適的大小

1156
00:51:46,987 --> 00:51:50,588
You can just click quite obvious in container and it's
你可以很容易的選中復選框

1157
00:51:50,590 --> 00:51:55,125
going to move the frame of all the buttons to fix the fact
這樣就會移動所有按鈕的 frame，修改

1158
00:51:55,127 --> 00:51:57,494
that they're in the wrong place based on their rules.
那些處於錯誤位置的

1159
00:51:57,496 --> 00:51:59,096
So let's try that.
讓我們試試看

1160
00:51:59,097 --> 00:52:00,697
I'm gonna hit this button here, Fix Misplacement.
我要點擊這個按鈕，「Fix Misplacement」

1161
00:52:01,933 --> 00:52:03,032
And it moved them all.
所有的按鈕都移動了

1162
00:52:03,034 --> 00:52:03,966
There's no more yellow.
沒有黃色的警告了

1163
00:52:03,968 --> 00:52:06,101
There's no auto layout issues.
沒有自動佈局的問題了

1164
00:52:06,103 --> 00:52:07,435
Okay. All looks good here.
看起來不錯

1165
00:52:07,437 --> 00:52:09,070
We can close our document outline.
可以關閉 document outline 視圖了

1166
00:52:10,306 --> 00:52:13,440
We zoom out, we can see, wow, it spread them all out.
將視圖縮小，可以看到按鈕充滿了整個視圖

1167
00:52:13,442 --> 00:52:14,675
Okay? Because,

1168
00:52:14,677 --> 00:52:18,444
maybe it's obeying those rules I gave it.
因為他們都遵守我定下的規則

1169
00:52:18,446 --> 00:52:20,079
Okay?

1170
00:52:20,080 --> 00:52:21,713
So let's now run this on some devices here and
現在，試試在不同的設備上運行

1171
00:52:21,716 --> 00:52:23,182
see what this looks like.
看看結果會怎樣

1172
00:52:26,220 --> 00:52:30,221
So turn off on an iPhone 6, which is a pretty tall device.
在 特別長的 iPhone 6 上

1173
00:52:30,223 --> 00:52:32,790
It's made, you know, kind of tall and thin.
iPhone 6 做的既長又窄

1174
00:52:32,792 --> 00:52:35,459
So if this still works fine enter.
一切正常

1175
00:52:35,461 --> 00:52:39,763
69874 times 5 divide maybe square root something like
輸入 5，enter，69874，乘法，5，除以，開平方根

1176
00:52:39,765 --> 00:52:44,266
that, it all seems to be working.
看起來運行正常

1177
00:52:44,268 --> 00:52:48,804
Now, not only is it working here in this portrait mode,
自動佈局不但在 iPhone 竪屏時工作正常

1178
00:52:48,806 --> 00:52:51,023
tall and thin.
既長又窄的情況

1179
00:52:51,024 --> 00:52:53,241
But if we go over here to this we can rotate the device.
如果我們從這裡旋轉設備

1180
00:52:54,277 --> 00:52:55,843
Okay, so I'm going to rotate left and
我要通過 ⌘ + 左，右鍵來

1181
00:52:55,845 --> 00:52:58,979
right and use the command keys to do this.
旋轉設備

1182
00:52:58,981 --> 00:53:02,449
And we rotate it right and you see it
設備向右轉可以看到

1183
00:53:02,451 --> 00:53:08,220
may the buttons spread out to this new location and
按鈕均勻分布到新的位置

1184
00:53:09,190 --> 00:53:13,491
we can rotate back using the command keys here.
可以用 ⌘ + 左，右鍵將設備轉回來

1185
00:53:14,627 --> 00:53:17,461
And it looks good in either orientation.
可以看到，在兩個方向上看起來都不錯

1186
00:53:17,463 --> 00:53:21,465
And in fact, it can look good on other devices as well.
實際上，在其他設備上同樣看起來很棒

1187
00:53:21,467 --> 00:53:23,066
So let's go over here and
點擊這裡

1188
00:53:23,068 --> 00:53:26,235
instead of doing iPhone 6, let's try it on an iPhone 4S.
這次不用 iPhone 6，試一下 iPhone 4S 上的效果

1189
00:53:26,237 --> 00:53:27,937
Okay so,

1190
00:53:27,939 --> 00:53:32,407
gonna switch the simulation here, let's run that.
切換模擬器，運行

1191
00:53:34,077 --> 00:53:37,345
Now the iPhone 4s, you can see is a little shorter,
現在是 iPhone 4S，它看起來短一點

1192
00:53:37,347 --> 00:53:39,280
it's not quite as tall.
並沒有那麼長

1193
00:53:39,282 --> 00:53:42,416
A little lower resolution, obviously.
很明顯，分辨率也有些低

1194
00:53:42,418 --> 00:53:46,986
But it relayed out the buttons to look good in that case too.
但是在這種情況下也將按鈕的位置擺放的很棒

1195
00:53:46,988 --> 00:53:52,558
9 times 9, divided by 8, square root, et cetera.
輸入 9，enter，9，乘法，8，除法，開平方等等

1196
00:53:52,560 --> 00:53:56,995
And same thing here we can rotate and
同樣我們可以旋轉

1197
00:53:56,997 --> 00:54:00,131
look at this one as well.
這樣看起來也不錯

1198
00:54:00,133 --> 00:54:03,067
Okay.
明白了嗎？

1199
00:54:03,069 --> 00:54:05,019
All righty.
好的

1200
00:54:05,020 --> 00:54:06,970
So the last thing I just want to talk about briefly is if
最後我想簡單說下

1201
00:54:06,973 --> 00:54:10,207
you try this extra credit and it doesn't work for you.
你嘗試得到額外加分，這是行不通的

1202
00:54:10,209 --> 00:54:16,413
Get all messed up, you can kind of start over by clicking
打亂所有限制，你可以通過點擊

1203
00:54:16,415 --> 00:54:21,450
on this and using the third button over here on the right.
這個位置並使用右邊第三個按鈕重新開始

1204
00:54:21,452 --> 00:54:23,852
And this allows you to reset your constraints and
這裡允許你重置你的約束，

1205
00:54:23,854 --> 00:54:26,688
you can see the top section here is the selected views.
你能看到上面的部分是被選中的視圖

1206
00:54:26,690 --> 00:54:27,922
I don't have any selected here so
我這裡沒有任何選中的視圖，因此

1207
00:54:27,924 --> 00:54:29,257
this wouldn't do anything right now.
現在這裡不能做任何操作

1208
00:54:29,259 --> 00:54:31,659
But the bottom is all views in container and
但是下面的部分是容器內的所有視圖

1209
00:54:31,661 --> 00:54:34,161
I kinda recommend going down here to all views
我推薦到下面所有視圖

1210
00:54:34,163 --> 00:54:37,164
container and clearing the constraints entirely.
容器內並清除所有約束

1211
00:54:37,166 --> 00:54:40,000
Reset to suggested constraints and try and
重置到建議的約束條件,

1212
00:54:40,002 --> 00:54:44,437
make some sense of your dashed lines but if it's not working,
但如果不工作，

1213
00:54:44,439 --> 00:54:47,673
you're probably, you're dashed lines are off anyway.
你很可能，

1214
00:54:47,675 --> 00:54:49,875
So you can just go here and
因此你僅僅需要到這裡

1215
00:54:49,877 --> 00:54:51,343
Clear Constraints, that'll clear them all.
清除所有約束條件，這將清除所有限制

1216
00:54:51,345 --> 00:54:53,211
Now that's gonna clear not just your buttons but
現在不僅僅需要清除你的按鈕，而且

1217
00:54:53,213 --> 00:54:55,880
also it's gonna clear your labels.
需要清除你的標籤

1218
00:54:55,882 --> 00:54:59,450
So you'll have to reposition your label with blue lines and
所以你必須使用藍色線條重新放置你的標籤並且

1219
00:54:59,452 --> 00:55:02,953
use control drag to say your top space, and, and
拖拽來確定你上部的空間

1220
00:55:02,955 --> 00:55:05,388
all that stuff, you know?
所有東西，瞭解？

1221
00:55:05,390 --> 00:55:08,458
If your buttons are really huge, they got really huge,
如果你所有按鈕確認很大，他們會變得很大，

1222
00:55:08,460 --> 00:55:10,726
but they're not in the right place, you can actually change
但是他們不能在正確的位置，你可以根據實際情況在工具窗口中調整

1223
00:55:10,728 --> 00:55:13,595
the size of all your buttons in the utilities window.
你的按鈕的大小

1224
00:55:14,565 --> 00:55:16,164
You can go to the size inspector right here,
有可以到尺寸查看器這裡

1225
00:55:16,166 --> 00:55:19,467
that's this one, you can actually type in the width and
這個位置你可以輸入所期望按鈕的實際寬度和

1226
00:55:19,469 --> 00:55:22,370
the height you want the buttons to be, make them
高度，確保他們

1227
00:55:22,372 --> 00:55:25,272
smaller again, which, you know, maybe 64 by 64.
再次變小，就像你所知道的那樣 可能是 64 x 64

1228
00:55:25,274 --> 00:55:29,376
That might make them easier to re-drag them into position so
這可以是他們變得容易再次拖拽到適當位置，

1229
00:55:29,378 --> 00:55:31,210
the blue lines are working.
藍色線條正常工作

1230
00:55:32,313 --> 00:55:36,015
And don't forget the very important blue line dragging,
不要忘記這個很重要的藍色線條的拖拽，

1231
00:55:36,017 --> 00:55:38,283
which is you want to take the whole grid and drag it,
你想要拖拽掙個格欄，

1232
00:55:38,285 --> 00:55:40,285
so that it's sitting underneath your label.
以至於它在你標籤下方

1233
00:55:41,654 --> 00:55:44,021
If you have problems dragging the whole grid underneath your
如果你拖拽你標籤下面的整個格欄有問題，

1234
00:55:44,023 --> 00:55:46,490
label, sometimes it's a good idea, clear all
通常清除所有約束限制是個好的做法

1235
00:55:46,492 --> 00:55:48,892
your constraints, kind of move your buttons out of the way,
移動你的按鈕到遠處，

1236
00:55:48,894 --> 00:55:51,761
just kind of move them down to the bottom here and then
僅僅移動他們到底部，然後

1237
00:55:51,763 --> 00:55:56,132
just for your label, do reset to suggest your constraint.
對你的標籤，做重置到建議的約束條件

1238
00:55:56,134 --> 00:55:57,499
This top one selected view
最上面那個被選中的視圖，

1239
00:55:57,501 --> 00:56:01,036
Rest Suggestion Constraints cuz that will work for
重置建議的約束條件英文這將對你的標籤起作用

1240
00:56:01,038 --> 00:56:03,204
the label if you move it into position as long as
你可以移動他倒適當位置只要

1241
00:56:03,206 --> 00:56:06,407
the buttons aren't too close and it thinks that, you know.
按鈕們不要靠的太近

1242
00:56:06,409 --> 00:56:08,042
Those buttons are near neighbors or something.
這些按鈕是進鄰或者其他什麼

1243
00:56:09,145 --> 00:56:11,945
And sometimes resetting it to suggest the constraints will
一些情況，重置到推薦約束

1244
00:56:11,947 --> 00:56:17,483
make it so that, that bottom edge of your UI label will
能做到，UI 標籤下邊緣是

1245
00:56:17,485 --> 00:56:21,253
be attainable when you drag your buttons into position.
可以達到的，當你拖拽一個按鈕到一個位置

1246
00:56:22,289 --> 00:56:23,538
But again, not to
但是，不要

1247
00:56:23,539 --> 00:56:24,788
worry too much about this auto layout stuff.
太擔心界面自動佈局的內容

1248
00:56:25,825 --> 00:56:27,158
It's extra credit in assignment one.
這是作業一的額外加分

1249
00:56:27,160 --> 00:56:29,493
It's not going to be extra credit in assignment two,
到了作業二就不是額外加分了

1250
00:56:29,495 --> 00:56:31,728
so you're eventually going to have to do it.
最終你都要做這件事

1251
00:56:31,730 --> 00:56:34,197
I'm going to be giving a big lecture on this in a couple of
我將花好幾個星期給你們好好講一下

1252
00:56:34,199 --> 00:56:35,465
weeks, on auto layout.
自動佈局

1253
00:56:35,467 --> 00:56:38,968
I've really just shown you just kind of what it can do,
我僅僅向你們展示了它的小小一角

1254
00:56:38,970 --> 00:56:41,770
I haven't really taught you how to do
我以前沒有教你們如何設置

1255
00:56:41,772 --> 00:56:43,338
auto layout in particular.
自動佈局

1256
00:56:44,374 --> 00:56:48,409
Auto layout is very important because we work in this
自動佈局十分重要因為我們

1257
00:56:48,411 --> 00:56:50,745
square area and
在這個方框被做工作

1258
00:56:50,746 --> 00:56:53,080
we want our UIs to work on all kinds of different devices.
我想要我們的界面能再各種不同設備上正常工作

1259
00:56:53,082 --> 00:56:54,614
That's why we're starting off in the very
這也是我們用它

1260
00:56:55,584 --> 00:56:57,717
start with some experience with it.
作為入門的原因

1261
00:56:59,820 --> 00:57:00,686
All right.
好了

1262
00:57:00,688 --> 00:57:02,520
So that is it.
就這樣

1263
00:57:02,522 --> 00:57:06,190
Now, later today, I'm gonna, in this lecture,
稍後，這次課中

1264
00:57:06,192 --> 00:57:10,828
I'm gonna give you a talk about this design paradigm
我將要給你講關於設計模式

1265
00:57:10,830 --> 00:57:14,197
called model-view-controller, and we actually designed our
叫做 模型 - 視圖 - 控制器，事實上我們設計的

1266
00:57:14,199 --> 00:57:17,300
calculator kind of poorly, because all of
計算器很差，因為這裡的所有

1267
00:57:17,302 --> 00:57:20,436
this code here is really nothing to do with UI.
代碼和界面沒有任何關係

1268
00:57:20,438 --> 00:57:26,141
This is all calculator brain, calculator engine code.
這是所有計算器的核心，計算器的引擎代碼

1269
00:57:26,143 --> 00:57:28,143
And this really wants to meet a different object and
這裡需要接觸一個不同的對象，

1270
00:57:28,145 --> 00:57:30,211
that's what MVC is all about.
這也就是 MVC

1271
00:57:30,213 --> 00:57:33,648
And so I'll give a little talk about MVC later today.
今天稍後我將講關於 MVC 的內容

1272
00:57:33,650 --> 00:57:36,650
And then on Monday, we're going to fix our calculator
然後再週一，我們將要解決我們計算器的問題，

1273
00:57:36,652 --> 00:57:41,855
to obey MVC and be a proper citizen in the iOS world,
達到遵循 MVC 架構，並成為 iOS 世界里的一員，

1274
00:57:41,857 --> 00:57:45,258
where all apps need to obey model V controller paradigm.
在這裡所有的程序都需要遵循 MVC 模式

1275
00:57:46,294 --> 00:57:49,261
>> So let's try and
understand for, I mean half of
來讓我們嘗試並理解，據你們說過半的人

1276
00:57:49,263 --> 00:57:52,764
you said that you already know MVC or you've seen it
知道 MVC 或者在其他

1277
00:57:52,766 --> 00:57:54,499
somewhere else so, this is going to be mostly review.
地方聽過它，因此這裡將是復習

1278
00:57:54,501 --> 00:57:57,769
But the other half of you, this will hopefully give you
另外一半人，這裡將給你

1279
00:57:57,771 --> 00:58:00,705
an idea of what MVC is all about.
一個 MVC 相關的概念

1280
00:58:00,707 --> 00:58:04,975
So MVC is basically a mechanism where we divide up
MVC 是一個基本機制，用於分類

1281
00:58:04,977 --> 00:58:09,379
all the objects in our application into one of
程序中的所有對象到

1282
00:58:09,381 --> 00:58:11,180
these three camps.
三個營地中的任意一個

1283
00:58:11,182 --> 00:58:12,281
Okay?
瞭解？

1284
00:58:12,283 --> 00:58:14,182
So, the three camps.
三個營地 （或者叫三層）

1285
00:58:14,184 --> 00:58:15,884
On the left there you see the model.
在左邊你看到的是模型

1286
00:58:15,886 --> 00:58:19,220
So, the model camp is gonna be all the objects that are what
模型層是那些對象的集合，這些對象是

1287
00:58:19,222 --> 00:58:21,355
your application does.
是程序的行為

1288
00:58:21,357 --> 00:58:24,858
So, for our calculator its, it calculates.
在我們計算器中，計算是模型

1289
00:58:24,860 --> 00:58:26,794
Okay, that's what it does.
那是計算器要做的

1290
00:58:26,795 --> 00:58:28,729
So, all the parts what we're doing perform operation, and
我們用於做執行操作的部分，和

1291
00:58:28,731 --> 00:58:32,098
all that stuff, that's all kind of calculator stuff.
相關材料，也就是計算器相關的內容

1292
00:58:32,100 --> 00:58:35,935
That should be in a calculator object somewhere else,
那些應屬於計算器對象

1293
00:58:35,937 --> 00:58:37,569
it shouldn't be in our controller.
不應該在我們的控制器中

1294
00:58:38,639 --> 00:58:43,841
And then the second camp is the controller, the controller
第二個陣營叫做 controller ，controller

1295
00:58:43,843 --> 00:58:48,178
controls how the model is presented on screen.
控制模型是如何顯示在屏幕上

1296
00:58:48,180 --> 00:58:51,348
And the view is the minions, the classes that
視圖是 controller 要

1297
00:58:51,350 --> 00:58:52,916
the controller is going to use are kind of
用到的的附屬類，有點類似於

1298
00:58:52,918 --> 00:58:55,485
like the the building blocks, the Lincoln Logs,
像積木，林肯積木，

1299
00:58:55,487 --> 00:58:57,520
I know maybe that's before all of your time.
我知道這也許是在你所有的時間。

1300
00:58:57,522 --> 00:59:00,289
But, you know, these things we're gong to do to build our
但是，這些事情是我們構建我們界面

1301
00:59:00,291 --> 00:59:02,524
UI, we're going to use in the view.
要做的事，我們在 view 中要用到它

1302
00:59:02,526 --> 00:59:06,127
So the stuff that's in the view is pretty generic, okay,
在 view 中的內容是相當通用的

1303
00:59:06,129 --> 00:59:07,795
generic UI elements.
的界面元素

1304
00:59:07,797 --> 00:59:10,030
The stuff in the controller is very specific to
在控制器中的內容是明確的，指出

1305
00:59:10,032 --> 00:59:11,498
how your UI works.
你的界面元素是如何工作的

1306
00:59:11,500 --> 00:59:13,600
And the stuff in the model is completely independent of
模型中的內容完全獨立於

1307
00:59:13,602 --> 00:59:15,234
how your UI works.
界面如何工作的

1308
00:59:15,236 --> 00:59:15,801
Okay?
懂嗎？

1309
00:59:15,803 --> 00:59:22,007
So doing MVC right is about knowing where things go but
因此正確的 MVC 不僅僅知道內容的存放位置而且

1310
00:59:22,009 --> 00:59:25,543
also about how to communicate between these three camps.
知道三層（camps）是如何通訊的

1311
00:59:25,545 --> 00:59:27,412
And so we can try and summarize how
我們來嘗試總結，

1312
00:59:27,414 --> 00:59:29,113
the communication works between these camps, and
三層之間是如何通訊的，

1313
00:59:29,115 --> 00:59:32,182
I've used road markings, you see the double yellow line and
我使用路面標線做講解，你看到的黃色雙線和

1314
00:59:32,184 --> 00:59:33,350
then the dashed white line.
白色虛線

1315
00:59:33,352 --> 00:59:34,884
So that's like you're driving in your car.
就像你駕駛你的汽車

1316
00:59:35,887 --> 00:59:40,356
Try to use them as an image for how this communication
嘗試用做以道路標線想象是如何通信的

1317
00:59:40,358 --> 00:59:42,090
happens, where it's allowed, where it's not allowed.
哪裡是允許通信的，哪裡是不被允許的

1318
00:59:43,093 --> 00:59:45,693
So let's talk about the Controller talking to
這樣，我們描述控制器是如何與

1319
00:59:45,695 --> 00:59:47,294
the Model.
模型

1320
00:59:47,296 --> 00:59:50,097
Going from that side of the road over to the Model side is
從控制器這側到模型 (Model) 這側是
1321
00:59:50,099 --> 00:59:51,565
a dashed white line, in other words,
白色虛線，換句話說，

1322
00:59:51,567 --> 00:59:52,799
you can head right across there.
你可以軋過虛線到另一側

1323
00:59:52,801 --> 00:59:54,267
You probably want to look before you go, but
你可能需要在你過對面之前觀察一下，但是

1324
00:59:54,269 --> 00:59:56,603
you can go right across, okay?
你可以正常穿越，對嗎？

1325
00:59:56,604 --> 00:59:58,938
The controller has to know everything about the model,
控制器必須瞭解 Model 的一切行為，

1326
00:59:58,940 --> 01:00:01,740
and it has to have complete ability to talk to
而且必須完全有能力和

1327
01:00:01,742 --> 01:00:04,776
the model, use its public API as much as it wants
模型（Model）通信，根據控制器需要，使用模型的開放 API

1328
01:00:04,778 --> 01:00:08,313
because the controller's job is to present the model to
因為控制器的職責就是展示模型（Model）給

1329
01:00:08,315 --> 01:00:10,848
the user using its view as its minions.
用戶，其視圖作為它的對象

1330
01:00:10,850 --> 01:00:12,650
So it has to have this access.
因此你必須有該權限

1331
01:00:12,652 --> 01:00:16,319
That full, unrestricted access the controller has talking to
控制器擁有的完全訪問權限可以與

1332
01:00:16,321 --> 01:00:17,320
the model.
模型通信

1333
01:00:17,322 --> 01:00:18,354
This is a one way arrow.
這是個單向箭頭

1334
01:00:18,356 --> 01:00:20,289
Control, or
控制器

1335
01:00:20,290 --> 01:00:22,223
one way arrow, from the controller to the model.
對模型的控制也是單向的

1336
01:00:22,226 --> 01:00:25,160
And similarly, from the controller to the view,
類似的，也可以從控制器到視圖，

1337
01:00:25,162 --> 01:00:27,095
is also unlimited communication,
也是允許通信的

1338
01:00:27,097 --> 01:00:28,830
because the controller is responsible for
因為控制器負責通過自身對象

1339
01:00:28,832 --> 01:00:30,798
talking using it's own minions.
向視圖發送指令

1340
01:00:30,800 --> 01:00:32,667
The view is, the controller's new meaning is
視圖是控制器設計

1341
01:00:32,669 --> 01:00:35,569
to lay out the user interface and all that stuff.
用戶界面的新方式

1342
01:00:35,571 --> 01:00:37,671
So, the controller can do anything it wants.
因此，控制器可以做任何它想做的事

1343
01:00:37,673 --> 01:00:39,305
I put that little green word, outlet,
我放置了一個綠色小字 Outlet 在上面，

1344
01:00:39,307 --> 01:00:42,809
up there because when we have a property of a controller
因為當我們有一個控制器的屬性，

1345
01:00:42,811 --> 01:00:46,278
that points into the view, we call it an outlet, okay?
該屬性指向視圖，我們稱它為 Outlet，懂嗎？

1346
01:00:46,280 --> 01:00:48,213
And you're gonna see that in the demo on Wednesday.
我們週三的展示中將要看到它

1347
01:00:48,215 --> 01:00:51,249
I'm gonna say, oh let's create an outlet from our controller
我想說的，讓我們創建一個 outlet， 從我們的控制器

1348
01:00:51,251 --> 01:00:52,634
to our view so
到我們的視圖

1349
01:00:52,635 --> 01:00:54,018
our controller can talk to it's view, all right?
這樣，我們控制器可以發送指令到對應視圖 對吧？

1350
01:00:55,055 --> 01:00:56,354
What about this communication?
這是如何通信的呢？

1351
01:00:56,356 --> 01:00:57,554
Model to view?
可以從 Model 到視圖嗎？

1352
01:00:57,556 --> 01:00:58,422
Never.
不可能！

1353
01:00:58,424 --> 01:00:59,989
And why is that?
為什麼會這樣呢？

1354
01:00:59,991 --> 01:01:03,292
100% obvious, the model is completely UI independent.
很明顯，Model 是完全獨立於 UI 的

1355
01:01:03,294 --> 01:01:05,494
So, there's absolutely no way it could talk to
因此，Model 沒有任何辦法向

1356
01:01:05,496 --> 01:01:07,863
a viewer object or anyone in that camp.
視圖對象發送指令，也不能和視圖層的任何對象通訊

1357
01:01:07,865 --> 01:01:10,399
Because the view objects are fundamentally UI objects.
因為視圖對象是基本的 UI 對象

1358
01:01:10,401 --> 01:01:11,466
They're kind of generic, but
他們是某種程度上是通用的，但是

1359
01:01:11,468 --> 01:01:13,401
they're still fundamentally UI objects.
他們也是基本的 UI 對象

1360
01:01:13,403 --> 01:01:16,237
Similarly, since the view objects are kind of generic,
同樣地，既然視圖對象是通用的對象，

1361
01:01:16,239 --> 01:01:18,272
they can't be talking to any specific model.
他們就不能和任何特定的 Model 對象通訊

1362
01:01:18,274 --> 01:01:20,674
They need a controller to interpret a model
他們需要用一個控制器來傳到信息

1363
01:01:20,676 --> 01:01:22,375
for them, okay?
懂嗎？

1364
01:01:22,377 --> 01:01:24,377
So there's never any communication this way.
因此這裡沒有任何通信

1365
01:01:24,379 --> 01:01:25,911
That's why it's a double yellow line.
這也是這裡使用黃色雙線的原因

1366
01:01:25,913 --> 01:01:27,780
That's why these lines are red.
這是這些線是紅色的原因

1367
01:01:27,782 --> 01:01:29,748
That's why there's fire, okay?
這也是這裡用火標注的原因 明白？

1368
01:01:29,750 --> 01:01:31,783
Never go across that line, Never.
永遠不要跨越這條線， 絕不！

1369
01:01:34,120 --> 01:01:36,520
What about the view talking back to the controller?
那視圖怎麼樣向控制器發送指令呢？

1370
01:01:36,522 --> 01:01:38,588
You got these generic view objects, like buttons.
你得到這些通用的視圖對象，例如按鈕

1371
01:01:38,590 --> 01:01:40,724
Can they talk to the controller?
他們能與控制器通信嗎？

1372
01:01:40,726 --> 01:01:43,593
Well, yes, they can.
對，當然可以

1373
01:01:43,595 --> 01:01:46,495
But, they have to be careful because the view objects
但是你必須小心，因為視圖對象

1374
01:01:46,497 --> 01:01:48,397
are generic.
是通用的

1375
01:01:48,398 --> 01:01:50,298
So they can't really know much about the controller.
這樣，他們不能真正的瞭解控制器

1376
01:01:50,301 --> 01:01:53,201
So, they can only communicate back to the controller
因此他們只能用盲目的方式和控制器通信，

1377
01:01:53,203 --> 01:01:55,437
in a blind way where they don't know the class of
視圖並不知道他們所通信的類

1378
01:01:55,439 --> 01:01:58,673
the thing they're talking to, and in a structured way.
在什麼位置，並用一種結構化的方式和控制器通信

1379
01:01:58,675 --> 01:02:02,776
A way where we all agree we're gonna communicate this way
這是一種大家都認同的，視圖和控制器通信的

1380
01:02:02,778 --> 01:02:03,844
between the view and the controller.
方式

1381
01:02:03,846 --> 01:02:05,512
So, whats an example of a structured way?
那，有沒有是結構化的方式例子？

1382
01:02:05,514 --> 01:02:07,480
Well one is called target action.
其中一個方式叫做 Target 操作

1383
01:02:07,482 --> 01:02:10,816
So, the controller basically drops a target on itself, and
一般控制器本身寫一個 target

1384
01:02:10,818 --> 01:02:15,087
then it hands out an action, which is like an arrow,
然後分給出一個操作方法，想一個箭頭

1385
01:02:15,089 --> 01:02:17,389
to the view and says to the view,
指向視圖，並和視圖通信

1386
01:02:17,391 --> 01:02:20,058
okay, when you do what you do, like you're a button and
當你想做了一個操作，比如你是一個按鈕，

1387
01:02:20,060 --> 01:02:21,659
someone touches you or your a slider and
別人點擊了你，或者你是個拖動條

1388
01:02:21,661 --> 01:02:24,828
someone moves you, send me that action.
別人移動了你，給向我發送那個操作

1389
01:02:24,830 --> 01:02:26,430
Okay?
懂嗎？

1390
01:02:26,431 --> 01:02:28,031
So, in this way, the generic button or
這樣，用這種方式，通用的按鈕或者

1391
01:02:28,033 --> 01:02:30,600
slider is communicating back to the controller.
拖動條就可以反過來和控制器通信

1392
01:02:30,602 --> 01:02:32,835
It has no idea that it's a card game controller or
它不知道這是一個紙牌遊戲控制器還是

1393
01:02:32,837 --> 01:02:34,103
a space game controller.
一個空間遊戲控制器

1394
01:02:34,105 --> 01:02:36,071
It doesn't know what kind of controller it is.
它並不知道它是什麼類型的控制器

1395
01:02:36,073 --> 01:02:38,607
All it knows is that when something happens in itself,
它所知道的只是某一個事件何時在它身上發生

1396
01:02:38,609 --> 01:02:40,108
boom, it sends a message to the target.
它發送一個消息給 target

1397
01:02:40,110 --> 01:02:43,678
So that's a blind, simple, structured way for
這樣就是一個盲目的，簡單的，結構化的方式來做

1398
01:02:43,680 --> 01:02:45,780
the view to communicate with the controller.
到視圖和控制器之間的通信

1399
01:02:45,782 --> 01:02:47,465
Okay?
明白嗎？

1400
01:02:47,466 --> 01:02:49,149
But what about more complicated ways?
那什麼是更複雜的通信方式呢？

1401
01:02:49,151 --> 01:02:52,119
Sometimes the view, things are happening in the view
有時，發生在視圖上的事件

1402
01:02:52,121 --> 01:02:53,987
that are somewhat complicated, and
是比較複雜的，

1403
01:02:53,989 --> 01:02:56,456
the controller needs to be informed of what's going on,
控制器需要知道正在發生的事是什麼，

1404
01:02:56,458 --> 01:02:58,791
synchronizing what's happening.
同步正在發生的事件

1405
01:02:58,793 --> 01:03:01,694
And one way to think about this is these words I
理解這個的一種方法是我放著

1406
01:03:01,696 --> 01:03:04,096
put up here, will, should and did.
will, should 和 did 這些單詞，

1407
01:03:04,098 --> 01:03:06,598
When the view is kind of like,
當某種視圖

1408
01:03:06,600 --> 01:03:08,132
let's say I am in the scroll view and
就比如說是在一個 scroll 視圖中，

1409
01:03:08,134 --> 01:03:11,669
I am scrolling around, and I want to let the controller
我正在到處滾動，並且我想要讓控制器

1410
01:03:11,671 --> 01:03:15,806
somebody know that the user just did scroll.
知道用戶剛剛做了滾動操作

1411
01:03:15,808 --> 01:03:17,691
Okay? Or
懂嗎？或者

1412
01:03:17,692 --> 01:03:19,575
the user puts down the touch and is about to scroll, I want
用戶按住屏幕，將要滑動，我想讓

1413
01:03:19,578 --> 01:03:23,413
to let the controller know the user will be scrolling, okay?
控制器知道用戶將要執行滑動操作 懂嗎？

1414
01:03:23,415 --> 01:03:25,114
Or, the user puts the touch down and
或者用戶按住屏幕

1415
01:03:25,116 --> 01:03:26,448
the scroll viewer wants to know,
scroll viewer 需要知道

1416
01:03:26,450 --> 01:03:30,452
should I allow the user to scroll here, is that allowed?
是否允許用戶這裡執行滾動操作？

1417
01:03:30,454 --> 01:03:33,221
All those things, the scroll view itself might not
這裡所有的事情，scroll 視圖本身或許沒有

1418
01:03:33,223 --> 01:03:36,190
have enough logic to know the answer to those questions.
足夠的邏輯知道那些問題的答案

1419
01:03:36,192 --> 01:03:39,727
So what it does is, it delegates the authority to
那它做的事情是，它代理給

1420
01:03:39,729 --> 01:03:42,730
answer those questions to some other object.
其他對象來回答那些問題

1421
01:03:42,732 --> 01:03:44,664
Now, it doesn't know the class of that object.
現在，它並不知道那個對象的類是什麼

1422
01:03:44,666 --> 01:03:46,199
All it knows is that other object can
他知道只是另一個對象可以

1423
01:03:46,201 --> 01:03:49,135
answer these questions, will, should, did, this, that, or
回答這些問題，will, should, did, this, that, 或者

1424
01:03:49,137 --> 01:03:51,570
the other thing like, should allow scrolling.
其他事情，像是否允許滑動

1425
01:03:51,572 --> 01:03:53,939
Did scroll to point.
滑動到一個點

1426
01:03:53,941 --> 01:03:54,539
Things like that.
就像那樣

1427
01:03:54,541 --> 01:03:56,591
So those are the kind of
這些是這樣一類

1428
01:03:56,592 --> 01:03:58,642
methods you are going to see in these delicate protocols.
方法，你將要在那些代理協議中看到他們

1429
01:03:58,645 --> 01:04:00,878
Now, I know this here is 1, 6 a and b,
現在，我知道這裡是 1，6，a 和 b

1430
01:04:00,880 --> 01:04:02,847
do not teach protocols.
沒有教過協議，

1431
01:04:02,849 --> 01:04:04,582
How many people know what
多少人知道

1432
01:04:04,583 --> 01:04:06,316
the word protocol means an
object during a programming?
協議在編程中代表什麼對象？

1433
01:04:06,318 --> 01:04:07,117
I can see very few of you.
很少能做到

1434
01:04:07,119 --> 01:04:08,818
So, I will be teaching that.
這裡我將要講它

1435
01:04:08,820 --> 01:04:12,421
A protocol is just a blind way to talk to another object.
協議僅僅是 blind 和其他對象通信的方式

1436
01:04:12,423 --> 01:04:13,556
When I teach it,
我講了它以後，

1437
01:04:13,557 --> 01:04:14,690
you're gonna be like oh, yeah, I know what that is.
你將會明白，這知道這就是它

1438
01:04:14,692 --> 01:04:16,958
So we can really call it protocol or whatever.
我們實際上叫它協議，或者不管什麼了

1439
01:04:16,960 --> 01:04:19,160
But that's how we do delegation, okay,
但這是我們如何實現一個代理，

1440
01:04:19,162 --> 01:04:20,862
this blind communication.
盲目通信

1441
01:04:21,931 --> 01:04:24,932
Also another important thing is
另一個重要事情是

1442
01:04:24,934 --> 01:04:28,502
that views should not own the data that they're displaying.
視圖不應該持有他們展示的數據

1443
01:04:28,504 --> 01:04:30,170
They should not own it.
他們不應該持有數據

1444
01:04:30,171 --> 01:04:31,837
In other words, it shouldn't be a property inside of them,
換句話說，數據不應該作為視圖內部的屬性，

1445
01:04:31,840 --> 01:04:34,707
where that's the truth of that data.
這就是數據。

1446
01:04:34,709 --> 01:04:37,810
And the easiest example for this is, all the songs in
最簡單的例子就是，在

1447
01:04:37,812 --> 01:04:40,679
your iPod, on your iPhone or your iPad, right?
你 iPod,iPhone 或者 iPad 中的所有歌曲 對嗎？

1448
01:04:40,681 --> 01:04:43,281
You might have 10,000 songs in there.
你可能有 10000 首歌曲

1449
01:04:43,283 --> 01:04:46,017
So, if you have some kind of generic list view in
假如你有一些通用的視圖列表在你視圖中，

1450
01:04:46,019 --> 01:04:50,354
your view, you can't transfer all 10,000 songs to its
你不能傳遞 10000 首歌到它的

1451
01:04:50,356 --> 01:04:52,773
instance variables, and
實例變量中，並

1452
01:04:52,774 --> 01:04:55,191
expect it to hold 10,000 songs so it can list through it.
期望它來持有 10000 首歌，來展示給你看

1453
01:04:55,194 --> 01:04:56,860
A, that would be inefficient, and
第一，這樣做是很低效的，

1454
01:04:56,862 --> 01:05:01,064
B that information, those 10,000 songs belongs where?
第二，這 10000 首歌屬於哪一層？

1455
01:05:01,066 --> 01:05:02,131
In the model.
在 Model 層

1456
01:05:02,133 --> 01:05:04,900
Okay, because your song database is a model.
OKay，因為你的音樂數據庫是一個 Model

1457
01:05:04,902 --> 01:05:06,468
It has nothing to do with UI.
它和 UI 沒有任何關係

1458
01:05:06,469 --> 01:05:08,035
It's just a list of songs and artists and albums and
視圖僅僅是歌曲，藝術家，專輯和其他信息的一個列表

1459
01:05:08,038 --> 01:05:09,604
all that, it's in the model.
它在 Model 層

1460
01:05:09,606 --> 01:05:12,073
Some controller has to look at that database and
一些控制器必須查詢數據並

1461
01:05:12,075 --> 01:05:16,243
tell a view how to display all those songs.
告訴一個視圖如何展示這些歌曲

1462
01:05:16,245 --> 01:05:18,429
Okay?
懂嗎？

1463
01:05:18,430 --> 01:05:20,614
So, we need that communication to happen here and the view is
這裡，我們這裡需要通信產生, 視圖

1464
01:05:20,616 --> 01:05:23,249
displaying some sort of list, and you're touching down and
展示列表分類，並且當你按下屏幕，

1465
01:05:23,251 --> 01:05:26,619
you're flicking on the list and trying to see more songs,
你輕輕滑動列表，試圖查看更多歌曲，

1466
01:05:26,621 --> 01:05:28,087
how does that communication happen?
這些通信如何發生的？

1467
01:05:28,089 --> 01:05:30,923
And the answer is, we have another special kind of
答案是我們 有另一種特殊的

1468
01:05:30,925 --> 01:05:33,992
delegate, which we call a data source.
代理，我們叫它數據源

1469
01:05:33,994 --> 01:05:36,928
Now the data source doesn't do the will did should.
數據源並不做 will, did, should 的事

1470
01:05:36,930 --> 01:05:39,230
It's gonna be asking questions like count,
它將回答類似，數量

1471
01:05:39,232 --> 01:05:41,098
like how many songs are there?
像這裡有多少首歌？

1472
01:05:41,100 --> 01:05:42,900
And the controller looks in the model,
控制器查找 Model

1473
01:05:42,902 --> 01:05:45,435
10,000 response to the view.
把 10000 返回給視圖

1474
01:05:45,437 --> 01:05:47,020
There's 10,000. The view
這是 10000, 視圖

1475
01:05:47,021 --> 01:05:48,604
makes space internally for 10,000 things.
為 10000 歌開闢內部空間

1476
01:05:48,607 --> 01:05:50,340
It doesn't know what they are.
視圖並不知道這些歌曲是什麼

1477
01:05:50,342 --> 01:05:53,009
Moves the scroll bar indicator a little bit so
稍微移動滾動條

1478
01:05:53,011 --> 01:05:54,276
that you know where it is.
你便能知道它在哪裡

1479
01:05:54,278 --> 01:05:57,779
And then you start scrolling, flipping through it, and
當你開始滾動，輕滑動它，

1480
01:05:57,781 --> 01:06:00,849
it starts sending the message to the controller,
它開始發送消息給控制器

1481
01:06:00,851 --> 01:06:03,785
give me the data at line 150 next 10 items.
返回 150 行後面的 10 條數據

1482
01:06:03,787 --> 01:06:04,975
You see what I mean?
你懂我意思嗎？

1483
01:06:04,976 --> 01:06:06,164
And then you flick down some more.
然後你再往下輕輕滑動

1484
01:06:06,165 --> 01:06:07,353
Now it's saying 250, 10 more items.
現在顯示 250， 另外 10 條數據

1485
01:06:07,357 --> 01:06:10,257
And so the control is going back to the model and
控制器再次與 Model 通信，並

1486
01:06:10,259 --> 01:06:11,725
saying give me more, give me more data.
要求得到更多的數據

1487
01:06:11,727 --> 01:06:14,361
And it's providing it to the view in this blind way.
控制器用這種 blind 方式提供數據給視圖

1488
01:06:14,363 --> 01:06:17,230
So to see how the view is getting data from the model
來看一下視圖如何從 Model 得到數據,

1489
01:06:17,232 --> 01:06:20,232
through the controller in this kind of blind structured way.
是通過控制器用這種 blind structured 方式實現的

1490
01:06:20,234 --> 01:06:21,767
Okay?
懂嗎？

1491
01:06:21,768 --> 01:06:23,301
That makes sense to everybody?
每個人都明白嗎？

1492
01:06:23,304 --> 01:06:24,970
So data source is just a kind of delegate,
數據源只是一種代理

1493
01:06:24,972 --> 01:06:27,105
it's a specific kind of delegate for getting data.
它是一種特殊類型的用於獲取數據的代理

1494
01:06:27,107 --> 01:06:30,408
So you're gonna see that there are classes in iOS that have
因此你將在 iOS 中看到一些類，

1495
01:06:30,410 --> 01:06:33,477
a data source, and they usually also have a delegate.
他們有一個數據源，並且通常有一個代理

1496
01:06:33,479 --> 01:06:36,547
Most sophisticated classes in iOS have a delegate, the will,
大部分 iOS 高級類有代理，包括 will,

1497
01:06:36,549 --> 01:06:38,415
did, should, kind of things.
did, should, 等要做的事

1498
01:06:38,417 --> 01:06:40,316
Some of them have a data source,
其中一些有數據源，

1499
01:06:40,318 --> 01:06:43,219
it depends on whether they are showing a lot of data or not.
這取決於他們是否要顯示大量數據

1500
01:06:43,221 --> 01:06:46,455
Now simple data, like if I had a view, if I invented a view
一些簡單的數據，比如我給紙牌遊戲

1501
01:06:46,457 --> 01:06:49,224
for my card game called Playing Card View and
創建了一個叫 Playing Card View 的視圖

1502
01:06:49,226 --> 01:06:51,109
it just has a suit and a rank.
它僅有花色和點數兩點屬性

1503
01:06:51,110 --> 01:06:52,993
Okay, we're not going to do count data app for
我們不會為了花色和點數

1504
01:06:52,996 --> 01:06:54,262
just suit and rank.
進行計算

1505
01:06:54,264 --> 01:06:56,030
We are going to set those properties.
我們會把它們設置成屬性

1506
01:06:56,032 --> 01:06:58,766
And so the view then would have that data set in it but
所以 view 里會有設置好的數據，但是

1507
01:06:58,768 --> 01:07:00,267
it wouldn't be owning it.
它不會擁有這些數據

1508
01:07:00,269 --> 01:07:02,536
Right? The model would still be
model 仍然會是花色和點數的

1509
01:07:02,538 --> 01:07:04,571
owning the suit and
擁有者

1510
01:07:04,572 --> 01:07:06,605
rank, the view is just getting that data to present it.
view 僅僅是為了顯示而獲取那些數據

1511
01:07:06,608 --> 01:07:07,840
'Kay. So simple data,
所以對於簡單的數據，

1512
01:07:07,842 --> 01:07:10,743
we might transfer to the view but it's merely for
我們會把它傳遞到 view 里，但是

1513
01:07:10,745 --> 01:07:12,878
it to display it.
只是給 view 來顯示

1514
01:07:12,880 --> 01:07:14,312
Okay.

1515
01:07:14,314 --> 01:07:17,615
This all adds up to the controller's job being to
所以 controller 的工作就是

1516
01:07:17,617 --> 01:07:22,520
interpret and format the model's data for the view.
給 view 解釋並格式化這些 model 提供的數據

1517
01:07:22,522 --> 01:07:23,654
That's the controller's job.
這就是 controller 的工作

1518
01:07:23,656 --> 01:07:25,188
And when we do our demo,
在我們做 deomo 的時候，

1519
01:07:25,190 --> 01:07:28,758
I'm going to be marking like, oh see I'm writing this code.
我會在寫代碼的時候提示大家，

1520
01:07:28,760 --> 01:07:31,494
This is to make the controller perform its job,
這段代碼是為了讓 controller 執行它的工作，

1521
01:07:31,496 --> 01:07:34,430
which is to take the model data and
也就是從 model 中取出數據然後

1522
01:07:34,432 --> 01:07:36,265
using its view minion to put it on screen.
送到 view 中去，然後顯示到屏幕上

1523
01:07:36,267 --> 01:07:37,132
Okay? That's what
這就是

1524
01:07:37,134 --> 01:07:38,667
the controller does.
controller 做的事情

1525
01:07:38,669 --> 01:07:40,468
What about this communication?
那關於通信呢？

1526
01:07:40,470 --> 01:07:42,970
Can the model talk to the controller?
model 可以和 controller 通信嗎？

1527
01:07:42,972 --> 01:07:46,040
Again, obviously that's verboten because model knows
同樣的，顯然是不可以 因為 model 對於 UI

1528
01:07:46,042 --> 01:07:47,708
nothing about UI, so
一無所知，所以

1529
01:07:47,710 --> 01:07:50,710
it couldn't possibly talk to a UI object like the controller.
它不可能同像 controller 一樣的 UI 對象進行通信

1530
01:07:50,712 --> 01:07:53,046
But sometimes things change in the model, and
但是有些時候，model 中的數據變了，

1531
01:07:53,048 --> 01:07:54,580
the controller needs to know about it, okay?
controller 需要知道這個變化

1532
01:07:54,582 --> 01:07:56,782
Data changes, a database changes or
數據改變了，數據庫改變了，或者

1533
01:07:56,784 --> 01:07:59,017
the model is some network database, and
model 是網絡數據庫，

1534
01:07:59,019 --> 01:08:01,186
somebody changes something on the network and it changes.
某人在網絡上修改了數據，數據改變了

1535
01:08:01,188 --> 01:08:02,587
And the controller needs to find out.
controller 需要瞭解這些

1536
01:08:02,589 --> 01:08:04,555
So, how do we do that communication?
所以，我們怎樣進行這種通信呢？

1537
01:08:05,958 --> 01:08:09,592
We do that using kind of a radio station model.
這可以通過一種電台的模型來理解

1538
01:08:09,594 --> 01:08:11,928
Okay?

1539
01:08:11,929 --> 01:08:14,263
So, the model, a radio station concept, the model will use
所以，model 是一種電台的概念，

1540
01:08:14,265 --> 01:08:17,866
this concept to essentially broadcast information to
model 將會利用這一概念，把信息廣播給

1541
01:08:17,868 --> 01:08:19,768
anyone who's interested.
感興趣的任何人

1542
01:08:19,770 --> 01:08:21,937
Okay?

1543
01:08:21,938 --> 01:08:24,105
And the mechanisms for doing this in iOS are called
在 iOS 中為瞭解決這種問題而使用的技術我們叫做

1544
01:08:24,107 --> 01:08:28,476
Notification and Key Value Observing, KVO we call it.
Notification 和 KVO

1545
01:08:28,478 --> 01:08:31,211
And so, the model can just say, oh, anytime
所以，model 可以這樣，

1546
01:08:31,213 --> 01:08:33,547
something changes in my model I'm just gonna broadcast on
我當中的任何東西發生了變化，我會通過我的電台

1547
01:08:33,549 --> 01:08:37,484
my radio station, and then the controller simply tunes into
廣播一下，隨後，controller

1548
01:08:37,486 --> 01:08:40,453
that radio station, and he can find out things are changing.
會接收到來自電台的信息，它會發現數據在變化

1549
01:08:40,455 --> 01:08:42,254
And when he finds out something changes,
發現數據變化以後，

1550
01:08:42,256 --> 01:08:46,058
it's gonna communicate via its green arrow to the model and
它就會通過它的綠剪頭同 model 進行通信，

1551
01:08:46,060 --> 01:08:47,659
say, okay, give me that data that changed.
給我那個改變過的數據

1552
01:08:48,962 --> 01:08:49,560
Right?

1553
01:08:49,562 --> 01:08:50,978
That make sense?
能聽懂嗎？

1554
01:08:50,979 --> 01:08:52,395
So, towards the end of the quarter we'll start seeing
所以在課程快要結束的時候，我們將會學習

1555
01:08:52,398 --> 01:08:54,531
a little how to do notification to find out, for
如何利用 notification 得知

1556
01:08:54,533 --> 01:08:57,334
example, if the data in a database changes.
例如數據庫中的數據發生了改變

1557
01:08:57,336 --> 01:09:00,070
We'll get a notification, the UI can then, you know,
我們將會獲取一個 notification，UI 的 controller

1558
01:09:00,072 --> 01:09:03,272
controller can then go talk to the model to get the info.
隨後可以同 model 通信來獲取信息

1559
01:09:05,309 --> 01:09:06,286
Okay?

1560
01:09:06,287 --> 01:09:07,264
Some people have asked,
有些人會問，

1561
01:09:07,265 --> 01:09:08,242
can a view tune into the radio station?
view 可以接收廣播嗎？

1562
01:09:08,245 --> 01:09:09,878
They probably could, but
它們也許可以，但是

1563
01:09:09,880 --> 01:09:11,179
you probably wouldn't want to do that.
你最好不要這樣做

1564
01:09:11,181 --> 01:09:12,980
That would probably be a violation of MVC.
這可能違背了 MVC 的原則

1565
01:09:12,982 --> 01:09:14,749
All right.

1566
01:09:14,751 --> 01:09:16,750
So we do this.
我們這樣做，

1567
01:09:16,752 --> 01:09:18,785
We have all this nice communication and
我們有這些很好的通信方式和

1568
01:09:18,787 --> 01:09:21,288
all these rules,
所有的這些規則

1569
01:09:21,289 --> 01:09:23,790
and we can imagine building something simple using this.
我們可以利用這些來製作一些小的應用

1570
01:09:23,792 --> 01:09:26,259
But what if we wanna build a big complicated app?
但是如果我們想要製作一個巨大複雜的應用呢？

1571
01:09:26,261 --> 01:09:28,861
An app that has multiple screens on our iPhone, or
一個在 iPhone 或 iPad 上運行，有多個屏幕，

1572
01:09:28,863 --> 01:09:30,863
an iPad, it's got three or
在屏幕上有三個或四個不同的區域，

1573
01:09:30,865 --> 01:09:34,166
four different areas on screen where things are happening.
都發生著事情

1574
01:09:34,168 --> 01:09:35,433
How do we do that?
我們該怎麼做？

1575
01:09:35,435 --> 01:09:36,834
Well, we're essentially going to
我們會結合

1576
01:09:36,836 --> 01:09:40,071
combine multiple MVCs, okay?
多個 MVC

1577
01:09:40,073 --> 01:09:47,244
Because an MVC can use as part of its view, another MVC.
因為一個 MVC 可以將另一個 MVC 當做視圖的一部分

1578
01:09:47,246 --> 01:09:48,311
Okay?

1579
01:09:48,313 --> 01:09:52,114
So an MVC, an entire MVC can be one of
所以一個完整的 MVC 可以被一個稍大些的

1580
01:09:52,116 --> 01:09:56,051
the minions of some bigger MVC.
MVC 當做僕從使用

1581
01:09:56,053 --> 01:09:57,803
'Kay?

1582
01:09:57,804 --> 01:09:59,554
And by doing that and cascading it down,
我們可以一層一層地這樣堆疊，

1583
01:09:59,556 --> 01:10:01,756
we can build more and more complicated applications.
就可以製作出越來越複雜的應用

1584
01:10:01,758 --> 01:10:07,561
So, an example of this is, you might have your calendar app,
例如，你可能有一個日曆應用，

1585
01:10:07,563 --> 01:10:09,930
and it's showing you the entire year.
它展示給你一整年的信息

1586
01:10:09,932 --> 01:10:12,599
And you click on a month, and now it shows you a month view.
隨後你點擊了一個月份，於是它展示給你月視圖

1587
01:10:12,601 --> 01:10:14,567
Well, a month view looks a lot different than a year view.
月視圖看起來和年視圖就不太一樣了

1588
01:10:14,569 --> 01:10:17,503
A month view just has all the days and maybe some circle
一個月視圖只含有日期，也許在日期上

1589
01:10:17,505 --> 01:10:19,204
that tells you where you have an appointment on a day.
會有一些通知你在某天會有任務的圈圈

1590
01:10:19,206 --> 01:10:20,939
And then when you click on a day, and
隨後，你點擊了一天，然後你

1591
01:10:20,941 --> 01:10:23,074
now you get a day view, okay?
獲得了一個日視圖

1592
01:10:23,076 --> 01:10:25,043
And the day is showing you the hours and what all
日視圖會顯示小時信息和這天你的所有任務，

1593
01:10:25,045 --> 01:10:27,611
your appointments are, and you click on the Appointment now
隨後你點擊了任務，

1594
01:10:27,613 --> 01:10:29,947
you get an appointment view and it showing the detail of
你會獲得任務視圖，它會顯示任務的細節，

1595
01:10:29,949 --> 01:10:32,182
where you're going and when it is et cetera, okay?
將要去哪，何時動身還有其它一些東西

1596
01:10:32,184 --> 01:10:36,452
Well, each of those views, year view, month view, the day
這些 view 中的每一個，年視圖，月視圖，日視圖，

1597
01:10:36,454 --> 01:10:40,155
view, and the appointment view are their own MVCs.
任務視圖，都有他們自己的 MVC

1598
01:10:40,157 --> 01:10:41,857
Okay?

1599
01:10:41,858 --> 01:10:43,558
But you can see how the last three, okay,
但是你可以發現，最後三個 view,

1600
01:10:43,560 --> 01:10:47,628
are used as essentially a minion of the top level view,
都被最頂層的年視圖為了展示更多的細節

1601
01:10:47,630 --> 01:10:51,032
year view, to show more detail, okay?
而被當做僕從使用

1602
01:10:51,034 --> 01:10:52,766
So the year view,you click on a month,
所以在年視圖里，你點擊了一個月份，

1603
01:10:52,768 --> 01:10:57,404
it's going to use the month view MVC to show more detail.
它會利用月份視圖的 MVC 來展現更多細節

1604
01:10:57,406 --> 01:11:00,406
So it's part of its view,okay?
所以它是它視圖的一部分，

1605
01:11:00,408 --> 01:11:03,476
So, you see this also in iOS with tab bar
所以你也在帶有 tab bar 的 iOS 應用

1606
01:11:03,478 --> 01:11:05,228
controllers, right?
中見過這些吧

1607
01:11:05,229 --> 01:11:06,979
You have the tab bar at the bottom, I have four or
在底部有一個 tab bar，有四個或五個

1608
01:11:06,981 --> 01:11:09,615
five things you can choose.
項可以供你選擇

1609
01:11:09,616 --> 01:11:12,250
Well there's some MVC at the top whose has four pointers to
在上面有一個 MVC，它指向四個僕從，

1610
01:11:12,252 --> 01:11:15,120
four minions, which are the four MVCs that are each going
也就是將要出現在

1611
01:11:15,122 --> 01:11:17,488
to appear in a tab bar, okay?
tab bar 的 MVC，

1612
01:11:17,490 --> 01:11:18,673
We'll be doing that for
我們將會做一個這方面的 demo，

1613
01:11:18,674 --> 01:11:19,857
example, in assignment number two or
在第二次或第三次作業，我們會

1614
01:11:19,859 --> 01:11:21,792
three where we'll be making a tab bar and
製作一個 tab bar，

1615
01:11:21,794 --> 01:11:25,328
you're gonna have to do multiple MVCs, okay?
你們將會學習如何使用多個 MVC

1616
01:11:25,330 --> 01:11:28,531
So, that basically results in a picture looks kinda
所以使用多個 MVC 的效果看起來就像

1617
01:11:28,533 --> 01:11:29,899
like this.
這張圖片一樣

1618
01:11:29,901 --> 01:11:31,434
All right?

1619
01:11:31,435 --> 01:11:32,968
Where you got this MVC, and
在你看到的這個 MVC 里，

1620
01:11:32,969 --> 01:11:34,502
you see the purple one that's like underneath the word
找到'together' 下面的那個

1621
01:11:34,505 --> 01:11:37,239
together there, and
紫色的，

1622
01:11:37,240 --> 01:11:39,974
it points to three other MVCs outside of its view thing.
它從 view 指向了另外三個 MVC，

1623
01:11:39,977 --> 01:11:40,542
Okay?

1624
01:11:41,478 --> 01:11:42,710
That's how we're going to build it, so
這就是我們創建 tab bar 的方式，

1625
01:11:42,712 --> 01:11:43,944
that might be a tab bar control and
這些可能就是它的

1626
01:11:43,946 --> 01:11:45,812
those might be the three tabs.
三個標籤

1627
01:11:45,814 --> 01:11:47,614
Okay, and each one is its own little MVC
並且它們每一個都是

1628
01:11:47,616 --> 01:11:50,249
completely independent, operates on its own.
完全獨立的，可以獨自行動的小 MVC

1629
01:11:50,251 --> 01:11:52,418
Doesn't even know,
這時它就是一個

1630
01:11:52,419 --> 01:11:54,586
it's a generic reusable view like thing at this point.
普通的可重用的 view 之類的東西，

1631
01:11:54,589 --> 01:11:56,689
Doesn't even know that it's in a tab bar.
它甚至不知道它在 tab bar 中

1632
01:11:56,691 --> 01:11:58,090
Okay, it just knows that it's supposed to do
它只知道它應該做

1633
01:11:58,092 --> 01:11:59,591
whatever it does.
這些事情

1634
01:11:59,593 --> 01:12:01,192
And so it's modular in that way.
所以在這方面，它是模塊化的

1635
01:12:01,194 --> 01:12:04,328
You can also see that there's no communication between any
可以看到這裡不再有其他箭頭，

1636
01:12:04,330 --> 01:12:06,397
other, there's no other arrows, except for
除了

1637
01:12:06,399 --> 01:12:08,249
some of the models.
一些 model

1638
01:12:08,250 --> 01:12:10,100
You see some of the models are communicating with each other.
某些 model 之間在互相通信

1639
01:12:10,102 --> 01:12:11,852
You know a big
要知道，

1640
01:12:11,853 --> 01:12:13,603
application might have a single shared model.
一個大型的應用也許會有一個單獨的共享 model

1641
01:12:13,605 --> 01:12:17,606
Or the models might be split off into pieces to be used by
或者，model 會被分開來

1642
01:12:18,876 --> 01:12:20,208
sub MVCs.
供子 MVC 使用

1643
01:12:20,210 --> 01:12:21,326
Okay? But
但是，

1644
01:12:21,327 --> 01:12:22,443
that's the only kind of communication you have there.
這裡只能使用這種通信方式

1645
01:12:22,446 --> 01:12:23,678
All other communication is
其它所有的通信

1646
01:12:23,680 --> 01:12:26,681
either the structure view communication we saw on MVC,
要麼是 MVC 中的結構化通信，

1647
01:12:26,683 --> 01:12:29,716
or it's using MVCs as part of the view of another MVC.
要麼是將 MVC 用作另一個 MVC 視圖的一部分

1648
01:12:31,386 --> 01:12:32,385
Any question about that?
有問題嗎？

1649
01:12:33,688 --> 01:12:36,689
So we definitely don't want to be having designs that
所以我們當然不希望

1650
01:12:36,691 --> 01:12:38,190
look like this, okay?
設計成這樣，

1651
01:12:38,192 --> 01:12:39,824
Where everybody's talking to everybody.
所有都在互相通信，

1652
01:12:39,826 --> 01:12:41,459
We can't tell who's talking to what.
我們不能分清誰在和什麼通信

1653
01:12:41,461 --> 01:12:43,994
It's just impossible to debug a program like this, and
這會讓調試程序變得異常艱難，

1654
01:12:43,996 --> 01:12:45,446
it doesn't scale.
而且它無法規模化

1655
01:12:45,447 --> 01:12:46,897
You can't build really big programs this way.
你不能通過這種方式創建出大程序

1656
01:12:46,899 --> 01:12:48,165
It just becomes impossible to
這樣的話，

1657
01:12:48,167 --> 01:12:51,634
know how touching anything would break everything, right?
你無法弄清楚，什麼地方會引發整個程序的崩潰

1658
01:12:51,636 --> 01:12:53,469
So we're definitely not going to be doing that.
所以我們絕對不會這樣做的

1659
01:12:54,639 --> 01:12:57,573
All right so that's MVC and,
所以，這就是 MVC，

1660
01:12:57,575 --> 01:13:00,875
like I say, on Monday we'll apply MVC to our calculator.
我們將會在週一的課里把 MVC 應用到我們的 calculator 中

1661
01:13:01,845 --> 01:13:02,977
So what's coming up?
所以，接下來是什麼？

1662
01:13:02,979 --> 01:13:06,146
I always try to get to this slide every lecture.
我每節課都盡量講到這裡，

1663
01:13:06,148 --> 01:13:09,716
Sometimes I forget but it's posted in the slides.
有時我會忘記，但是它被放到了投影片中

1664
01:13:09,718 --> 01:13:12,018
It says tomorrow is Friday.
週五也就是明天，

1665
01:13:12,020 --> 01:13:14,320
No, day after tomorrow is Friday.
不對，後天的週五，

1666
01:13:14,322 --> 01:13:17,256
And people who are watching on iTunes U,
在 iTunes U 上觀看的同學們，

1667
01:13:17,258 --> 01:13:19,858
these Friday sections will not be on iTunes U so
週五的部分不會被放到 iTunes U 上，

1668
01:13:19,860 --> 01:13:22,461
don't go looking for them only the normal Monday,
只有週一和週三的才會被放上去，

1669
01:13:22,463 --> 01:13:24,596
Wednesday lectures went on iTunes U.
所以不要到處找

1670
01:13:25,999 --> 01:13:27,164
But, for Stanford students,
但是對於在坐的同學，

1671
01:13:27,166 --> 01:13:30,300
Friday we have this debugger section we talked about.
週五我們將討論之前談到的調試部分

1672
01:13:30,302 --> 01:13:32,769
And then next Monday,
下週一，你們的閱讀作業

1673
01:13:32,771 --> 01:13:35,638
your reading assignment is gonna be due.
將會截至

1674
01:13:35,640 --> 01:13:37,040
In other words, you should be done with that
換句話說，你應當在週一上課之前

1675
01:13:37,042 --> 01:13:40,176
reading assignment before the start of Monday's lecture.
完成閱讀作業

1676
01:13:40,178 --> 01:13:43,045
And I'm gonna assign you another reading assignment.
我會再佈置給你們一個閱讀作業

1677
01:13:43,047 --> 01:13:45,180
It might be your only other reading assignment.
它將會是你們最後一個閱讀作業

1678
01:13:45,182 --> 01:13:46,815
Perhaps there'll be a reassignment three,
也許以後還會有閱讀作業，

1679
01:13:46,817 --> 01:13:48,383
but it won't be any more than that.
但是不會像那個一樣多

1680
01:13:49,318 --> 01:13:50,351
And then on Wednesday I'm
下週三，我會深入介紹

1681
01:13:50,353 --> 01:13:53,420
really gonna dive into Swift and Foundation.
Swift 語言和 Foundation 框架

1682
01:13:53,422 --> 01:13:56,556
I'm gonna talk a little bit about the Objective C legacy,
我將會介紹一點遺留下來的 Objective-C

1683
01:13:57,625 --> 01:13:59,425
and then your assignment one is gonna be
你們的作業一將會在

1684
01:13:59,427 --> 01:14:00,792
due a week from today.
一周後截止

1685
01:14:00,794 --> 01:14:05,129
It's been posted for you, and your assignment two is gonna
你們已經看到了，作業二將會在

1686
01:14:05,131 --> 01:14:08,032
go out next Wednesday and be due the Wednesday after that.
下週三佈置下去，下下週三截止

1687
01:14:08,034 --> 01:14:09,900
Just for a little bit of advanced planning for
提前為你們所有人

1688
01:14:09,902 --> 01:14:11,335
all of you.
做一些計劃

1689
01:14:11,337 --> 01:14:12,235
Okay?

1690
01:14:12,237 --> 01:14:13,202
Any other questions?
還有問題嗎？

1691
01:14:14,439 --> 01:14:15,904
Okay, thank you.
好的，謝謝

1692
01:14:15,906 --> 01:14:19,808
>> For more, please visit us at stanford.edu.
>> 想瞭解更多，請登錄 stanford.edu
